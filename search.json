[{"title":"模块","url":"/2020/04/07/js基础/模块/","content":"#### 位置\n```\nexport和import都必须出现在使用他们的最顶层作用域（必须出现在所有代码块和函数的外面）\n```\n#### 导出实例\n##### 第一中方式\n```\nexport function foo(){}\nexport let bar = 1234\n```\n##### 第二种方式\n```\nfunction foo(){}\nlet bar = [1,2,3]\nexportc {foo,bar}\n```\n##### 未导出\n```\n没有用export导出的在模块作用域内保持私有\n```\n##### 导出时重命名\n```\nfunction foo(){}\nexport {foo as bar}\n```\n##### 导出实际上是对这些东西的绑定（类似于指针，不是简单的赋值操作）\n```\n如果你在模块内部修改已经导出的绑定的变量值，即使已经导入的，导入的绑定值也将会决议到更新后的值\nlet foo = 123\nexport {foo}\nfoo = 456\n导入的值会是456而不是123\n\n本质上绑定的是一个指向foo的引用而不是foo值的复制\n```\n#### 默认导出\n##### 形式\n```\n两种写法\nfunction foo(){}\nexport default foo;\n\nexport default function foo(){}\n上面导出的是函数表达式值的绑定，而不是foo ，export default 接受一个表达式，\n如果之后在你的模块中给foo赋一个不同的值，模块导入的是原来的值而不是新的值。\n\nfunction foo(){}\nexport {foo as default} \n更新模块，这个方式会更新对应的值\n\n注：每个模块只能由一个default\n```\n#### 默认导出对象的不合理\n```\nexport default{\n    foo(){},\n    bar(){}\n}\njavascript引擎无法静态分析平凡对象的内容\n即无法对静态import进行性能优化\n让每个成员独立且显示地导出的优点是引擎可以对其进行静态分析和优化\n\n所以推荐使用\nexport default function(){}\nexport bar(){}\nexport baz(){}\n形式\n\n或者\nexport {foo as default,bar,baz}\n```\n#### 再次导出\n```\nexport {foo ,bar } from 'baz'\n'baz'模块的成员不会导入到你的局部模块作用域，而会不留痕迹地穿过\n```\n#### import模块\n```\nimport模块会提升到作用域的最顶部\n```","tags":["import和export"],"categories":["js"]},{"title":"正则表达式","url":"/2020/04/06/js正则表达式/正则表达式/","content":"```\nlastIndex 属性用于规定下次匹配的起始位置。\n\n（不具有标志 g 和不表示全局模式的 RegExp 对象不能使用 lastIndex 属性。\n如果在成功地匹配了某个字符串之后就开始检索另一个新的字符串，需要手动地把这个属性设置为 0。）\n```\n```\ntest(string) 方法用于检测一个字符串是否匹配某个模式.\n定点标识y，/ /y从lastIndex属性指定位置开始匹配。前次匹配失败后重置。\n```\n```\nmatch() 方法可在字符串内检索指定的值，或找到一个或多个正则表达式的匹配。\n该方法类似 indexOf() 和 lastIndexOf()，但是它返回指定的值，而不是字符串的位置。\n```","tags":["正则表达式"],"categories":["js"]},{"title":"global和window","url":"/2020/04/06/js基础/global和window/","content":"#### console.log(global);\n```\nObject [global] {\n  global: [Circular],\n  clearInterval: [Function: clearInterval],\n  clearTimeout: [Function: clearTimeout],\n  setInterval: [Function: setInterval],\n  setTimeout: [Function: setTimeout] { [Symbol(util.promisify.custom)]: [Function] },\n  queueMicrotask: [Function: queueMicrotask],\n  clearImmediate: [Function: clearImmediate],\n  setImmediate: [Function: setImmediate] {\n    [Symbol(util.promisify.custom)]: [Function]\n  }\n}\n```\n#### console.log(window)\n```\nWindow {parent: Window, opener: null, top: Window, length: 0, frames: Window, …}\n```","tags":["global,window"],"categories":["js"]},{"title":"let和var","url":"/2020/04/06/js基础/let和var/","content":"#### 浏览器中window对象访问\n```\nlet，const 声明的变量不会绑定给window对象 而var会\n```\n```\nlet foo =33\nwindow.foo\n//undefined\nvar bar =44\nwindow.bar\n//44\nthis.bar\n//44\n```\n#### 暂时性死区：\n```\n只要块级作用域内存在let命令，它所声明的变量就“绑定”在这个区域，不再受外部的影响。所以在使用变量后声明变量会报错。\n```","tags":["let,var"],"categories":["js"]},{"title":"箭头函数的问题","url":"/2020/04/06/js基础/箭头函数的问题/","content":"#### 浏览器中window和this\n```\nthis.Number\nƒ Number() { [native code] }\n\nwindow.Number\nƒ Number() { [native code] }\n\nthis.Number === window.Number\ntrue\n```\n#### nodejs中\n```\nconsole.log(this); //{}\nthis.obj = \"123456\";\nconsole.log(this.obj); //123456\nconsole.log(global.obj); //undefined\nconsole.log(module.exports.obj); //123456\n//全局中的this指向的是module.exports而不是global\n```\n#### 在普通函数中的this\n```\nfunction foo() {\n    this.bar = \"111111\";\n}\nfoo();\n\nconsole.log(global.bar);//111111\n//函数中的this指向的是global对象\n```\n#### 在构造函数中的this\n```\nfunction foo(){\n    this.bar = '123456';\n}\nlet baz = new foo();\nconsole.log(baz.bar); //123456\nconsole.log(global.bar); //undefined\n//在构造函数中this指向的是它的实例\n```\n#### 箭头函数的设计目的\n```\n以特定的方式改变this的行为特性\n在箭头函数的内部，this绑定不是动态的，而是词法的\n```\n#### 箭头函数的问题\n```\nlet obj ={\n    foo :()=>{\n        console.log(this)\n        this.bar()\n    },\n    bar:()=>{\n        console.log('123456')\n    }\n}\n//{}\n//TypeError: this.bar is not a function\n//this指向module.exports.而不是obj\n```\n#### 使用情况\n```\n1.简单的函数表达式(函数没有this的引用，没有自身引用(递归，事件绑定，解绑定)，且函数不会执行这些内容)\n2.函数依赖于var self = this或者.bind(this)\n3.函数依赖于var args = Array.prototype.slice.call(arguments)\n4.其他情况尽量避免使用箭头函数\n```\n```\n除了this词法，箭头函数还有词法arguments，\n他们没有自己的arguments数组，而是继承自父层，\n还有词法super和new.target也一样\n```\n```\n=>是关于this,arguments和super的词法绑定\n```","tags":["箭头函数"],"categories":["js"]},{"title":"problems","url":"/2020/04/04/problems/问题总汇/","content":"#### Port 3000 is already in use\n```\nnetstat -ano|findstr \"3000\"\n    TCP    0.0.0.0:3000           0.0.0.0:0              LISTENING       7952\n    TCP    [::]:3000              [::]:0                 LISTENING       7952\n    \ntaskkill -PID 7952 -F\n```","tags":["problems"],"categories":["problems"]},{"title":"http基础","url":"/2020/04/02/http/http/","content":"### 计算机网络的七层\n应用层、表示层、会话层、传输层、网络层、数据链路层、物理层","tags":["http基础"],"categories":["http"]},{"title":"css水平居中","url":"/2020/04/02/css/水平居中/","content":"## 水平居中\n### 1.margin\n```\ndiv{\n    height:200px;\n    width:200px;\n    margin:0 auto;\n}\n```\n### 2.绝对定位\n```\ndiv{\n    height:200px;\n    width:200px;\n    position:absolute;\n    left:50%\n    transform:translateX(-50%);\n}\n```\n### 3.display\n```\ndiv{\n    display:flex;\n    justify-content:center;\n}\n```\n### 4.文本居中\n```\ndiv{\n    text-align:center\n}\n```","tags":["水平居中"],"categories":["css"]},{"title":"css垂直居中","url":"/2020/04/02/css/垂直居中/","content":"## 垂直居中的方式(块级元素)\n### 1.绝对定位\n#### 1.1 绝对定位+margin\n```\ndiv{\n    position: absolute;\n    top: 0; left: 0; bottom: 0; right: 0;\n    height: 200px;\n    width: 200px;\n    background-color: #232323;\n    /*水平垂直居中*/\n    margin: auto;\n}\n```\n```\ndiv{\n    position: absolute;\n    top: 0; left: 0; bottom: 0; right: 0;\n    height: 200px;\n    width: 200px;\n    background-color: #232323;\n    /*垂直居中*/\n    margin-top:auto;\n    margin-bottom: auto;\n}\n```\n```\n原理:\n1.在普通内容流中，margin:auto的效果等同于margin-top:0;margin-bottom:0。\n2.position:absolute使绝对定位块跳出了内容流，内容流中的其余部分渲染时绝对定位部分不进行渲染。\n3.为块区域设置top: 0; left: 0; bottom: 0; right: 0;将给浏览器重新分配一个边界框，此时该块块将填充其父元素的所有可用空间，所以margin 垂直方向上有了可分配的空间。\n4.再设置margin 垂直方向上下为auto，即可实现垂直居中。（注意高度得设置）。\n```\n#### 1.2 绝对定位+top+left\n```\ndiv{\n    position: absolute;\n    height: 200px;\n    width: 200px;\n    background-color: #232323;\n    top: 50%;\n    left: 50%;\n    transform: translate(-50%,-50%);\n}\n```\n### 2.弹性布局display:flex\n```\ndiv{\n    height: 600px;\n    width: 600px;\n    border: 1px solid black;\n    margin: 0 auto;\n    display: flex;\n    align-items: center; \n}\n```\n### 3.display:table此元素会作为块级表格来显示（类似 <table>），表格前后带有换行符。\n```\ndiv{\n    display: table;\n    height: 200px;\n    width: 200px;\n    background-color: #232323;\n    vertical-align: center;\n}\nvertical-align该属性定义行内元素的基线相对于该元素所在行的基线的垂直对齐。允许指定负长度值和百分比值。这会使元素降低而不是升高。\n\n在表单元格中，这个属性会设置单元格框中的单元格内容的对齐方式。\n```\n## 2.行内元素\n```\nline-height = height\n\n行内元素特征：\n(1)设置宽高无效\n(2)对margin仅设置左右方向有效，上下无效；padding设置上下左右都有效，即会撑大空间\n(3)不会自动进行换行\n```","tags":["垂直居中"],"categories":["css"]},{"title":"单词记录","url":"/2020/04/02/单词表/单词/","content":"```\nexceeded超过; 超越的限制; exceed的过去分词和过去式\n```\n```\nmultilingual\n[ˌmʌltiˈlɪŋɡwəl] \nadj.多种语言的\n```\n```\nnormalize[ˈnɔːməlaɪz]\nv.(使)正常化，标准化，常规化\n```","tags":["生词记录"],"categories":["word"]},{"title":"hexo问题","url":"/2020/04/01/hexo/hexo/","content":"### hexo 的问题记录\n#### hexo发布后样式丢失\n修改配置中url路径，和root\n\n#### FATAL Something's wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.html\nError: Spawn failed\n    at ChildProcess.<anonymous> (E:\\STUDY\\hexo\\node_modules\\hexo-util\\lib\\spawn.js:52:19)\n    at ChildProcess.emit (events.js:200:13)\n    at ChildProcess.cp.emit (E:\\STUDY\\hexo\\node_modules\\cross-spawn\\lib\\enoent.js:40:29)\n    at Process.ChildProcess._handle.onexit (internal/child_process.js:272:12)\n    \n删除 .deploy_git重新hexo c &&hexo g && hexo d","tags":["setting"],"categories":["hexo"]},{"title":"Set和Map","url":"/2020/04/01/js基础/set和map/","content":"#### 创建Map\n##### new创建\n```\nMap是一组键值对的结构，具有极快的查找速度。\nlet foo = new Map([[1, 10], [2, 20], [3, 30]]);\nMap传入的值必须是一个二维数组\n```\n##### 初始化空Map\n```\nlet foo = new Map();\nfoo.set(1,10);\nfoo.get(1);\nfoo.has(1)\nfoo.delete(1)\n\n输出:Map { 1 => 10 }\n10\ntrue\ntrue\n```\n#### 创建Set\n##### new创建\n```\nSet和Map类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在Set中，没有重复的key。\nlet foo = new Set([1,2])\nSet传入一个数组\nSet { 1, 2 }\n```\n##### 初始化空Set\n```\nlet foo = new Set()\nfoo.add(1)\nfoo.delete(1)\n\n输出结果:\nSet { 1 }\ntrue\n```\n#### Set Map 普通对象\n```\n1.普通对象的key值必须是string\nMap,Set的key值可以是任意值\n2.Set只有key没有value\n3.key值不能重复\n```","tags":["Set-Map"],"categories":["js"]},{"title":"node基础","url":"/2020/03/31/node/io/","content":"## node.js基础整理\n## I/O\nIO端口，I/O输入/输出(Input/Output)，分为IO设备和IO接口两个部分。每个设备都会有一个专用的I/O地址，用来处理自己的输入输出信息。I/O地址绝对不能重复，如果两个设备的I/O地址有冲突，系统硬件就不能正常工作。\n## node为什么选择js\njs没有自带的I/O，有良好的事件支持机制\n## 模块\n### 模块化\n#### 关键词require，exports，module\n#####1.1 require\n例:let foo = require('./bar.js');\n##### 1.2 exports\n例:exports.hello = function () { console.log(\"Hello World!\"); }\n##### 1.3 module\n例:module.exports = function () { console.log(\"Hello World!\"); }\n##### 注释:exports是module.exports的引用\nmodule.exports既可以通过点语法，也可以直接赋值一个对象    \n例:module.exports.xxx=xxx\nmodule.exports=xxx，\nexports只能用\".\"例:exports.xxx=xxx\n#####","tags":["node"],"categories":["js"]},{"title":"微信小程序","url":"/2020/03/19/小程序/微信/","content":"微信小程序(开个坑)\n#### wx.navigateTo和wx.redirectTo的区别","tags":["微信小程序"],"categories":["js"]},{"title":"call apply bind","url":"/2020/03/14/js基础/call/","content":"### call bind 和apply的异同点\n#### 1. call和apply\n```\ncall() 和apply()方法使用一个指定的  *this值* 和单独给出的一个或多个参数来调用一个函数。\n```\n```\nfunction Foo(name,age){\n    this.name = name;\n    this.age = age;\n}\nfunction Bar(name,age,id){\n    Foo.call(this,name,age);\n    this.id = id;\n}\nconsole.log(new Bar('张三',20,1001).name);\nconsole.log(new Bar('张三',20,1001).id);\n//张三\n//1001\n```\n#### 2. 区别\n```\napply(this值,[数组])\ncall(this值,参数1,参数2,...)\n```\n#### 3. 如果不设置第一个参数\n```\nes6默认严格模式，输出undefined，而不会指向全局对象\nlet name = '张三';\nfunction foo(){\n    console.log(this.name);\n}\nfoo.call();\n//undefined\n```\n#### 4. bind\n```\nbind() 方法创建一个新的函数，\n在 bind() 被调用时，\n这个新函数的 this \n被指定为 bind()的第一个参数，\n而其余参数将作为新函数的参数，供调用时使用。\n```\n##### 3.1 typeof (Foo.call(this, name, age))\n```\nfunction Foo(name,age){\n    this.name = name;\n    this.age = age;\n}\nfunction Bar(name,age){\n    Foo.call(this,name,age);\n    console.log(typeof (Foo.call(this, name, age)));\n}\nconsole.log(new Bar('张三',20).name);\n//undefined\n//张三\n```\n##### 3.2 typeof (Foo.bind(this, name, age))\n```\nfunction Foo(name,age){\n    this.name = name;\n    this.age = age;\n}\nfunction Bar(name,age){\n    Foo.bind(this,name,age);\n    console.log(typeof (Foo.bind(this, name, age)));\n    (Foo.bind(this, name, age))();\n}\nconsole.log(new Bar('张三',20).name);\n//function\n//张三\n```\n#### 区别\n```\n普通函数this指向为方法调用的对象，可以通过bind，call，apply改变this的指向，\nbind将当前函数与指定的对象绑定，并返回一个新函数。\nbind和call，apply调用方式不同，call和apply传参方式不同\n```","tags":["js-call-bind-apply"],"categories":["js"]},{"title":"react学习记录","url":"/2020/03/13/react/react学习/","content":"react学习记录(开个坑)\n","tags":["react"],"categories":["js"]},{"title":"基础类型和引用类型","url":"/2020/03/12/js基础/类型/","content":"#### 基础类型和引用类型的区别\n#### js类型\n##### 1. 基础类型\n```\nnumber ,string,null，undefined，Boolean\n\n赋值的时候传递的是值\n\n变量名和值直接存在在栈内存中\n```\n\n##### 2.引用类型\n```\nObject,Array,Function\n\n赋值的时候传递的是引用\n\n变量名(引用)存放在栈内存中，实际值存放在堆内存中\n\n原因:引用值的大小会改变，所以不能放在栈中，否则会降低变量查询的速度,\n当我们把引用类型传递给变量的时候，此时我们传递的是引用类型的地址\n```","tags":["type"],"categories":["js"]},{"title":"java数组","url":"/2020/03/12/java/java数组/","content":"### java数组的基础知识\n#### 1. 数组的创建方式\n```\n数组的 声明\n类型[] 数组名 ;\nint[] arr;\n\n数组的 创建\nnew 类型[数组大小];\narr =new int[10];\n三种方式\n(1) int[] arr = new int[10];\n(2) int[] arr = {1,2,3};\n(3) int[] arr = new int[]{1,2,3};\n```\n\n#### 2. 注意点\n```\n1.通过下标访问\n2.下标不能越界\n3.创建后大小固定，无法扩容或缩小\n3.每个元素的类型是一样的\n4.数组不是基本数据类型不能进行强制类型转换\n5.不兼容低精度数据赋值给高精度数据，但数组元素间支持\n6.没有赋值的数组int型默认值为0；\nchar默认值为nul(invisible不可见),boolean默认值为false，\nString为null\n7.数组的数据类型不是基本数据类型的数组是引用类型\n```\n#### 3. 数组的clone方法\n##### 3.1 数组的数据类型为基础类型\n调用clone方法会返回一个新的数组\n注意点:使用clone方法的时候需要进行强制类型转换\n```\nint[] arr = {1,2,3};\nint[] clonedArr = (int[]) arr.clone;\n```\n##### 3.2 数组的数据类型不再是基本数据类型/*****或者是多维数组的直接clone*****\n```\nclone方法不会产生新的数组，而是生成一个指向数组的引用\n```\n##### 3.3 多维数组的最后一层参照基础类型","tags":["java-array"],"categories":["java"]},{"title":"迭代器","url":"/2020/03/11/js基础/迭代器/","content":"### 迭代器的原理和工作方式\n### 1. Symbol.iterator 为每一个对象定义了默认的迭代器。该迭代器可以被 for...of 循环使用，和 ...运算符 操作。\n#### 1.1 Object身上没有Symbol.iterator，直接使用时会报undefined\n````\nlet obj ={}\nconsole.log(obj[Symbol.iterator]);\n//udefined\n````\n````\nlet foo ={\n    'bar':1,\n    'baz':2\n}\nfor (let v of foo){\n    console.log(v);\n}//TypeError: foo is not iterable\n````\n#### 1.2 Array自带Symbol.iterator\n````\nlet arr=[];\nconsole.log(arr[Symbol.iterator]());\n//Object [Array Iterator] {}\n````\n#### 1.3 两种相同的声明方式\n````\nlet foo1 ={\n    'bar':function(){\n        console.log(1);\n    }\n}\nconsole.log(foo1['bar']());\n//1\n\nlet foo2 ={\n    ['bar']:function(){\n        console.log(2);\n    }\n}\nconsole.log(foo2['bar']());\n//2\n````\n#### *生成器本身不是迭代器，当你执行生成器的时候就能得到一个迭代器\n#### *生成器在yield处暂停 ，生成器的状态会被保持\n#### 1.4 obj实现for of\n#### ES6 同时提供了 Symbol.iterator 属性，只要一个对象有这个属性，就会被视为有 Iterator 接口\n````\nlet foo ={\n    'bar':1,\n    'baz':2\n}\nfoo[Symbol.iterator] = function(){\n    let index = 0,\n        self = this,\n        keys = Object.keys( self );\n\n    return {\n        next(){\n            if( index < keys.length ){\n                return {\n                    value: self[keys[index++]],\n                    done: false\n                };\n            }\n            else{\n                return {\n                    value: undefined\n                    , done: true\n                }\n            }\n        }\n    }\n}\n\nfor (let v of foo){\n    console.log(v);\n}\n````","tags":["迭代器"],"categories":["js"]},{"title":"生成器","url":"/2020/03/11/js基础/生成器/","content":"### 生成器的运作方式和原理\n#### 1. 功能：打破完整的函数运行。函数运行到断点yield处会停止运行，用迭代器.next()来控制一步步往下运行，同时函数不再只有一个返回值\n\n````\nfunction* foo() {\n       let x = yield 2;\n       console.log(x);\n       let y = yield (x * 2);\n       console.log(y);\n   }\n   \n   let it = foo();\n   console.log(it.next());\n   console.log(it.next(20));\n   console.log(it.next(1000));\n   \n   输出结果：   \n   2，\n   20，\n   40，\n   1000，\n   { value: undefined, done: true }\n\n//在yield处设置断点，第一个.next()用于启动生成器，不传入值；\n然后yield会将其后面的值当作返回值返回，运行到第二个.next()，\n传入20，用20这个值赋值给 x 输出x的值20；并继续运行到下个yield，\n下个yield会将x*2的值返回；运行到第三个.next()传入1000并赋值给 \ny 输出y的值1000函数默认返回undefined,done true表示迭代结束\n````\n\n","tags":["生成器"],"categories":["js"]},{"title":"git代理","url":"/2020/02/25/git/代理/","content":"### github设置代理\n#### 设置ss\n```\ngit config --global http.proxy 'socks5://127.0.0.1:1080'\n\ngit config --global https.proxy 'socks5://127.0.0.1:1080'\n```\n#### 设置代理\n```\ngit config --global https.proxy http://127.0.0.1:1080\n\ngit config --global https.proxy https://127.0.0.1:1080\n```\n\n#### 取消代理\n```\ngit config --global --unset http.proxy\n\ngit config --global --unset https.proxy\n```","tags":["setting"],"categories":["git"]},{"title":"回调","url":"/2020/02/24/js基础/回调/","content":"#### 1. 回调函数和普通函数的区别\n##### 1.1 普通函数：调用程序发出对普通函数的调用后，程序执行立即转向被调用函数执行，直到(被调用函数)执行完毕后，再返回调用程序继续执行。\n*程序调用普通函数-->等待被调用函数执行完毕-->继续执行程序\n##### 1.2 回调函数：（Callback）调用程序发出对回调函数的调用后，不等函数执行完毕，立即返回并继续执行。被调用函数进入循环队列。当被调函数执行完毕后，被调函数会反过来调用某个事先指定函数，以通知调用程序：函数调用周期结束，这个过程称为回调。\n<!-- more -->\n#### 2.定时器\n##### 2.1 node提供了四个定时器\n```\n    setTimeout()\n    setInterval()\n    setImmediate()\n    process.nextTick()\n```\n##### 2.2 速度对比\n```\n    setTimeout(() => console.log(1));\n    setInterval(() => console.log(2));\n    setImmediate(() => console.log(3));\n    process.nextTick(() => console.log(4));\n    Promise.resolve().then(() => console.log(5));\n    (() => console.log(6))();\n\n    结果： 6->4->5->1->2->3\n    先执行同步的(() => console.log(6))();\n    然后执行process.nextTick(() => console.log(4));\n    process.nextTick是定时器中速度最快的\n    然后执行Promise.resolve().then(() => console.log(5));\n    promise的速度仅次于process.nextTick\n```\n        \n```        \n    setInterval(() => console.log(2));\n    setImmediate(() => console.log(3));\n    setTimeout(() => console.log(1));\n    //3->2->1\n    setImmediate(() => console.log(3));\n    setTimeout(() => console.log(1));\n    setInterval(() => console.log(2));\n    //3->1->2\n    setTimeout(() => console.log(1));\n    setInterval(() => console.log(2));\n    setImmediate(() => console.log(3));\n    //1->2->3\n    setInterval(() => console.log(2));\n    setTimeout(() => console.log(1));\n    setImmediate(() => console.log(3));\n    //2->3->1\n    setImmediate(() => console.log(3));\n    setInterval(() => console.log(2));\n    setTimeout(() => console.log(1));\n    //3->2->1\n    setTimeout(() => console.log(1));\n    setImmediate(() => console.log(3));\n    setInterval(() => console.log(2));\n    //3->1->2\n```\n##### 2.3 总结: setInterval，setImmediate，setTimeout没有绝对的快慢","tags":["回调函数"],"categories":["js"]},{"title":"散列表冲突解决之分离链接","url":"/2019/09/19/基于js的数据结构与算法/散列表冲突解决分离链接/","content":"#### js散列表冲突解决分离链接方式\n```\nclass HashTableSeparateChaining {\n    constructor(toStrFn=defaultToString){\n        this.toStrFn =toStrFn;\n        this.table={};\n    };\n }\n//确保键一定是字符串\nlet defaultToString=function defaultToString(item) {\n    if (item===null){\n        return \"NULL\";\n    }else if (item ===undefined){\n        return \"UNDEFINED\";\n        // instanceof运算符用于测试构造函数的prototype属性是否出现在对象的原型链中的任何位置\n    }else if (typeof item===\"string\"||item instanceof String){\n        return `${item}`;\n    }\n    return item.toString();\n}\n\n\nclass ValuePair {\n    constructor(key,value){\n        this.key =key;\n        this.value=value;\n    }\n    toString(){\n        return `[#${this.key}:${this.value}]`;\n    }\n}\n//创建散列表(链式)\nclass HashTableSeparateChaining {\n    constructor(toStrFn=defaultToString){\n        this.toStrFn =toStrFn;\n        this.table={};\n    };\n\n    //散列函数\n    loseloseHashCode(key){\n        if (typeof key==='number'){\n            return key;\n        }\n        //转key为字符串\n        const tableKey =this.toStrFn(key);\n        let hash =0;\n        //charCodeAt() 方法可返回指定位置的字符的 Unicode 编码。\n        for (let i=0;i<tableKey.length;i++){\n            hash +=tableKey.charCodeAt(i);\n        }\n        return hash %37;\n    }\n    hashCode(key){\n        return this.loseloseHashCode(key);\n    };\n\n    //向散列表增加一个新项\n    put(key,value){\n        if(key !=null && value !=null){\n            //获取hashCode\n            const  position =this.hashCode(key);\n            if (this.table[position] == null){\n                this.table[position] =new LinkedList();\n            }\n            this.table[position].push(new ValuePair(key,value));\n            return true;\n        }\n        return false;\n    };\n    //从散列表获取一个值\n    get(key){\n        const position =this.hashCode(key);\n        const linkedList =this.table[position];\n        if (linkedList !=null &&!linkedList.isEmpty()){\n            let current =linkedList.getHead();\n            while(current !=null){\n                if (current.element.key===key) {\n                    return current.element.value;\n                }\n                current =current.next;\n            }\n        }\n        return undefined;\n    };\n    //从散列表中移除一个值\n    remove(key) {\n        const position = this.hashCode(key);\n        const linkedList =this.table[position];\n        if (linkedList !=null &&linkedList.isEmpty()){\n            let current =linkedList.getHead();\n            while(current !=null){\n                if (current.element.key===key){\n                    linkedList.remove(current.element);\n                    if (linkedList.isEmpty()){\n                        delete this.table[position];\n                    }\n                    return true;\n                }\n                current =current.next;\n            }\n        }\n        return false;\n    };\n    //toString方法\n    toString(){\n        if (this.isEmpty()){\n            return '';\n        }\n        const keys =Object.keys(this.table);\n        let objString =`{${keys[0]}=>${this.table[keys[0]].toString()}}`;\n        for (let i=1;i<keys.length;i++){\n            objString =`${objString},{${keys[i]}=>${this.table[keys[i]].toString() }}`;\n        }\n        return objString;\n    };\n\n    //size方法\n    size(){\n        return Object.keys(this.table).length;\n    }\n    //isEmpty方法\n    isEmpty(){\n        return this.size()===0;\n    }\n\n}\n\n\nconst hash =new HashTableSeparateChaining();\n\n\nhash.put('aaa','aaa@qq.com');\nhash.put('bbb','bbb@qq.com');\nhash.put('ccc','ccc@qq.com');\n\n// console.log(hash);\nconsole.log(hash.table);\nconsole.log(hash.toString());\n\n\n// console.log(hash.size());\n// console.log(hash.isEmpty());\n\n\n\n\n// console.log(hash.hashCode('aaa') + '-aaa');\n// console.log(hash.hashCode('bbb') + '-bbb');\n// console.log(hash.hashCode('ccc') + '-ccc');\n\n\n// console.log(hash.get('aaa'));\n// console.log(hash.get('ddd'));\n//\n// hash.remove('aaa');\n// console.log(hash.get('aaa'));\n\n\n\n\n```","tags":["散列表冲突解决之分离链接"],"categories":["数据结构与算法"]},{"title":"js散列表冲突解决线性探查","url":"/2019/09/19/基于js的数据结构与算法/散列表冲突解决线性探查/","content":"#### 散列表冲突解决线性探查方式\n```\nclass HashTableSeparateChaining {\n    constructor(toStrFn=defaultToString){\n        this.toStrFn =toStrFn;\n        this.table={};\n    };\n}\n\n//确保键一定是字符串\nlet defaultToString=function defaultToString(item) {\n    if (item===null){\n        return \"NULL\";\n    }else if (item ===undefined){\n        return \"UNDEFINED\";\n        // instanceof运算符用于测试构造函数的prototype属性是否出现在对象的原型链中的任何位置\n    }else if (typeof item===\"string\"||item instanceof String){\n        return `${item}`;\n    }\n    return item.toString();\n}\n\n\nclass ValuePair {\n    constructor(key,value){\n        this.key =key;\n        this.value=value;\n    }\n    toString(){\n        return `[#${this.key}:${this.value}]`;\n    }\n}\n//创建散列表\nclass HashTableSeparateChaining {\n    constructor(toStrFn=defaultToString){\n        this.toStrFn =toStrFn;\n        this.table={};\n    };\n\n    //散列函数\n    loseloseHashCode(key){\n        if (typeof key==='number'){\n            return key;\n        }\n        //转key为字符串\n        const tableKey =this.toStrFn(key);\n        let hash =0;\n        //charCodeAt() 方法可返回指定位置的字符的 Unicode 编码。\n        for (let i=0;i<tableKey.length;i++){\n            hash +=tableKey.charCodeAt(i);\n        }\n        return hash %37;\n    }\n    hashCode(key){\n        return this.loseloseHashCode(key);\n    };\n\n    //移动冲突元素的辅助函数\n    verifyRemoveSideEffect(key, removePosition) {\n        const hash =this.hashCode(key);\n        let index =removePosition+1;\n        while(this.table[index] !=null){\n            const posHash =this.hashCode(this.table[index].key);\n            //hash为原始值 removePosition上一个被移除key的hash值\n            if (posHash<=hash ||posHash <=removePosition){\n                this.table[removePosition]=this.table[index];\n                delete this.table[index];\n                removePosition =index;\n            }\n            index++;\n        }\n    };\n    //向散列表增加一个新项\n    put(key,value){\n        if (key !=null && value !=null){\n            const position =this.hashCode(key);\n            if (this.table[position]==null){\n                this.table[position]=new ValuePair(key,value);\n            } else{\n                let index =position +1;\n                while(this.table[index] !=null){\n                    index++;\n                }\n                this.table[index] =new ValuePair(key,value);\n            }\n            return true;\n        }\n        return false;\n    };\n    //从散列表获取一个值\n    get(key){\n        const position =this.hashCode(key);\n        if (this.table[position] !=null){\n            if (this.table[position].key ===key){\n                return this.table[position].value;\n            }\n            let index =position +1;\n            while(this.table[index]!=null &&this.table[index].key !=key){\n                index++;\n            }\n            if (this.table[index]!=null &&this.table[index].key ===key){\n                return this.table[position].value;\n            }\n        }\n        return undefined;\n    };\n    //从散列表中移除一个值\n    remove(key) {\n        const  position =this.hashCode(key);\n        if (this.table[position]!=null){\n            if (this.table[position].key ===key){\n                delete this.table[position];\n                this.verifyRemoveSideEffect(key,position);\n                return true;\n            }\n            let index =position+1;\n            while(this.table[index] !=null &&this.table[index].key !==key){\n                index++;\n            }\n            if (this.table[index] !=null &&this.table[index].key===key){\n                delete this.table[index];\n                this.verifyRemoveSideEffect(key,index);\n                return true;\n            }\n        }\n        return false;\n    };\n    //toString方法\n    toString(){\n        if (this.isEmpty()){\n            return '';\n        }\n        const keys =Object.keys(this.table);\n        let objString =`{${keys[0]}=>${this.table[keys[0]].toString()}}`;\n        for (let i=1;i<keys.length;i++){\n            objString =`${objString},{${keys[i]}=>${this.table[keys[i]].toString() }}`;\n        }\n        return objString;\n    };\n\n    //size方法\n    size(){\n        return Object.keys(this.table).length;\n    }\n    //isEmpty方法\n    isEmpty(){\n        return this.size()===0;\n    }\n\n\n}\n\n\nconst hash =new HashTableSeparateChaining();\n\n\nhash.put('aaa','aaa@qq.com');\nhash.put('bbb','bbb@qq.com');\nhash.put('ccc','ccc@qq.com');\n\n// console.log(hash);\nconsole.log(hash.table);\nconsole.log(hash.toString());\n\n\n// console.log(hash.size());\n// console.log(hash.isEmpty());\n\n\n\n\n// console.log(hash.hashCode('aaa') + '-aaa');\n// console.log(hash.hashCode('bbb') + '-bbb');\n// console.log(hash.hashCode('ccc') + '-ccc');\n\n\n// console.log(hash.get('aaa'));\n// console.log(hash.get('ddd'));\n//\n// hash.remove('aaa');\n// console.log(hash.get('aaa'));\n\n\n```","tags":["散列表冲突解决之线性探查"],"categories":["数据结构与算法"]},{"title":"集合","url":"/2019/09/19/基于js的数据结构与算法/集合/","content":"#### 集合的原理与实现\n```\nclass Set {\n    constructor(){\n        this.items={};\n    };\n    //实现集合的基础\n//js对向像一个键指向两个不同的属性，保证集合元素的唯一\n }\n//集合(表示一组互(不重复)不相同的元素)存储方式[值，值]\nclass Set {\n    constructor(){\n        this.items={};\n    };\n    //实现集合的基础\n//js对向像一个键指向两个不同的属性，保证集合元素的唯一\n\n    //has element方法\n    //1.使用js的in方法(返回表示对象在原型链上是否具有特定属性的布尔值)\n    has(element){\n      return element in items;\n    };\n\n    //2.原型链hasOwnProperty方法(返回一个表明对象是否有特定属性的布尔值)(安全做法)\n    has (element){\n        return Object.prototype.hasOwnProperty.call(this.items,element);\n    };\n    //添加一个元素//同时作为剪纸保存，便于查找\n    add(element){\n        if (!this.has(element)){\n            this.items[element]=element;\n            return true;\n        }\n        return false;\n    };\n    //delete 方法\n    delete(element){\n        if (this.has(element)){\n            delete this.items[element];\n            return true;\n        }\n        return false;\n    };\n    //clear方法\n    clear(){\n        this.items ={};\n    };\n    //size方法\n    //方法一：利用一个length变量记录\n    //方法二：\n    //利用Object的keys方法(返回一个包含给定对象所有属性的数组)\n    //方法三：手动提取items变量的每一个属性\n    size(){\n        return Object.keys(this.items).length;\n    };\n    //方法三：手动提取items变量的每一个属性\n    sizeLegacy(){\n        let count=0;\n        //for in 遍历会遍历原型链\n        for(let key in this.items){\n            if (this.items.hasOwnProperty(key)){\n                count++;\n            }\n            return count;\n        }\n    };\n    //values方法(内置方法)\n    values(){\n        return Object.values(this.items);\n    };\n    //手动遍历\n    valuesLegacy(){\n        let values=[];\n        for (let key in this.items){\n            if (this.items.hasOwnProperty(key)){\n                values.push(key);\n            }\n        }\n        return values;\n    };\n\n\n    //集合运算\n    // 并集\n    union(otherSet){\n        const unionSet =new Set();\n\n        let values =this.values();\n        for (let i=0;i<values.length;i++){\n            unionSet.add(values[i]);\n        }\n        values =otherSet.values();\n        for (let i=0;i<values.length;i++){\n            unionSet.add(values[i]);\n        }\n        return unionSet;\n    };\n\n    //交集\n    intersection(otherSet){\n        const intersectionSet =new Set();\n\n        const values =this.values();\n        for (let i=0; i<values.length;i++) {\n            if (otherSet.has(values[i])){\n                intersectionSet.add(values[i]);\n            }\n        }\n        return intersectionSet;\n    };\n\n    intersection(otherSet){\n        const intersectionSet =new Set();\n\n        const values=this.values();\n        const otherValues=otherSet.values();\n\n        let biggerSet =values;\n        let smallerSet=otherValues;\n        if (otherValues.length -values.length >0){\n            biggerSet =otherValues;\n            smallerSet =values;\n        }\n        smallerSet.forEach(value =>{\n            if (biggerSet.includes(value)){\n                intersectionSet.add(value);\n            }\n        });\n        return intersectionSet;\n    };\n\n    //差集\n    difference(otherSet){\n        const differenceSet =new Set();\n        this.values().forEach(value=>{\n            if(!otherSet.has(value)){\n                differenceSet.add(value);\n            }\n        });\n        return differenceSet;\n    };\n\n    //子集\n    isSubsetOf(otherSet){\n        if (this.size()>otherSet.size()){\n            return false;\n        }\n        //返回false,every循环结束\n        let isSubset =true;\n        this.values().every(value=>{\n            if (!otherSet.has(value)){\n                isSubset=false;\n                return false;\n            }\n            return true;\n        });\n        return isSubset;\n    }\n}\n\n\n\n//测试用例\n\nconst set =new Set();\n\nset.add(1);\nset.add(2);\nconsole.log(set);\n\n\n```","tags":["集合"],"categories":["数据结构与算法"]},{"title":"js字典","url":"/2019/09/19/基于js的数据结构与算法/字典/","content":"#### 构造字典\n```\nclass Dictionary {\n    //构造函数\n    constructor(toStrFn =defaultToString){\n        this.toStrFn =toStrFn;\n        this.table ={};\n    };\n }\n//确保键一定是字符串\nlet defaultToString=function defaultToString(item) {\n    if (item===null){\n        return \"NULL\";\n    }else if (item ===undefined){\n        return \"UNDEFINED\";\n        // instanceof运算符用于测试构造函数的prototype属性是否出现在对象的原型链中的任何位置\n    }else if (typeof item===\"string\"||item instanceof String){\n        return `${item}`;\n    }\n    return item.toString();\n}\n\n\n//字典中每个键只有一个值，以[键，值]形式存储元素\n// import defaultToString from './util';\n// **\n// export与export default均可用于导出常量、函数、文件、模块等\n// 2、你可以在其它文件或模块中通过import+(常量 | 函数 | 文件 | 模块)名的方式，将其导入，以便能够对其进行使用\n// 3、在一个文件或模块中，export、import可以有多个，export default仅有一个\n//valuePair类\nclass ValuePair {\n    constructor(key,value){\n        this.key =key;\n        this.value=value;\n    }\n    toString(){\n        return `[#${this.key}:${this.value}]`;\n    }\n}\n\n// 4、通过export方式导出，在导入时要加{ }，export default则不需要\nclass Dictionary {\n    //构造函数\n    constructor(toStrFn =defaultToString){\n        this.toStrFn =toStrFn;\n        this.table ={};\n    };\n    //检测一个键是否存在于字典中\n    //js只允许我们使用字符串作为对象的键名和属性名\n    hasKey(key){\n        return this.table[this.toStrFn(key)] !=null;\n    }\n    //set方法\n    set(key,value){\n        if (key !=null && value !=null){\n            const tableKey =this.toStrFn(key);\n            this.table[tableKey] =new ValuePair(key,value);\n            return true;\n        }\n        return false;\n    };\n    //remove方法\n    remove(key){\n        if (this.hasKey(key)){\n            delete this.table[this.toStrFn(key)];\n            return true;\n        }\n        return false;\n    };\n    //检索一个值get方法\n    get(key){\n        const valuePair =this.table[this.toStrFn(key)];\n        return valuePair ==null ?undefined :valuePair.value;\n    };\n\n    //keyValues方法\\\n    //方法一\n    keyValues(){\n        return Object.values(this.table);\n    }\n    //方法二\n    keyValues(){\n        const valuePairs =[];\n        for (const k in this.table){\n            if (this.hasKey(k)){\n                valuePairs.push(this.table[k]);\n            }\n        }\n        return valuePairs;\n    };\n    //keys方法\n    keys(){\n        return this.keyValues().map(valuePair =>{\n           return valuePair.key\n        });\n    };\n    //方法二\n    // keys(){\n    //   const keys=[];\n    //   const valuePairs =this.keyValues();\n    //   for (let i=0;i<valuePairs.length;i++){\n    //       keys.push(valuePairs[i].key);\n    //   }\n    //   return keys;\n    // };\n    values(){\n        return this.keyValues().map(valuePair => {\n            return valuePair.value;\n        });\n    };\n    //方法二\n    // values(){\n    //     const values=[];\n    //     const valuePairs =this.keyValues();\n    //     for (let i=0;i<valuePairs.length;i++){\n    //         values.push(valuePairs[i].value);\n    //     }\n    //     return values;\n    // };\n\n    //forEach\n    forEach(callbackFn){\n        const valuePairs =this.keyValues();\n        for (let i=0;i<valuePairs.length;i++){\n            const result =callbackFn(valuePairs[i].key,valuePairs[i].value);\n            if (result===false){\n                break;\n            }\n        }\n    };\n    //size方法\n    size(){\n        return Object.keys(this.table).length;\n        // return this.keyValues().length;\n    };\n    //isEmpty方法\n    isEmpty(){\n        return this.size()===0;\n    };\n    //clear方法\n    clear(){\n        return this.table={};\n    };\n    //toString方法\n    toString(){\n        if (this.isEmpty()){\n            return \"\";\n        }\n        const valuePairs =this.keyValues();\n        let objString =`${valuePairs[0].toString()}`;\n        for (let i=1;i<valuePairs.length;i++){\n            objString=`${objString},${valuePairs[i].toString()}`;\n        }\n        return objString;\n    };\n}\n//测试\nconst dictionary =new Dictionary();\ndictionary.set('aaaa',\"afdafad\");\ndictionary.set('bbbb',\"dfadfaf\");\ndictionary.set('cccc',\"ddsdffd\");\n\nconsole.log(dictionary.hasKey('aaaa'));\nconsole.log(dictionary.size());\nconsole.log(dictionary.get('aaaa'));\n// console.log(dictionary);\nconsole.log(dictionary.toString());\ndictionary.forEach((k,v)=>{\n    console.log('forEach:', `key:${k},value:${v}`);\n}) ;\nconsole.log(dictionary.keyValues());\nconsole.log(dictionary.values());\nconsole.log(dictionary.keys());\n\n```","tags":["dictionary"],"categories":["数据结构与算法"]},{"title":"this绑定规则","url":"/2019/08/15/js基础/this绑定规则/","content":"### js中this的绑定规则\n#### 绑定规则\n##### 1.默认绑定\n```\nthis的默认绑定指向全局变量\n\nfunction foo(){\n    console.log(this.a);\n}\nlet a=2;\nfoo();\n```\n##### 2.隐式绑定\n```\n调用位置的上下文对象（被某个对象拥有或者包含）\n\nfunction foo(){\n  console.log(this.a);\n}\nlet obj ={\n    a:2,\n    foo:foo\n}\nobj.foo();//2\n```\n##### 3.显式绑定\n```\n使用call()和apply()方法\n\nfunction foo(){\n    console.log(this.a);\n}\nlet obj={\n    a:2\n}\nfoo.call(obj);//2\n```\n普通的显式绑定无法解决隐式丢失问题\n(1)硬绑定 使用bind()方法\n能解决this隐式丢失的问题\n```\nfunction foo(){\n    console.log(this.a);\n    return this.a;\n}\n\nlet obj ={\n    a:2\n}\nlet bar =foo.bind(obj);\nconsole.log(2);//2\n```\n##### 4.new绑定\n```\n使用new来调用函数会执行下面的操作\n（1）创建一个全新的对象\n（2）这个对象会被执行原型链连接\n（3）这个对象会绑定到函数调用的this\n（4）如果函数没有其他返回对象，new表达式中的函数就会自动返回这个新对象\n\nfunction foo(a){\n  this.a=a;\n}\nlet bar =new foo(2);\nconsole.log(bar.a);//2\n```\n##### 优先级 new绑定>显式绑定>隐式绑定>默认绑定","tags":["js-this"],"categories":["js"]},{"title":"js隐式丢失this绑定的情况","url":"/2019/08/15/js基础/this隐式丢失/","content":"#### 隐式丢失this绑定的情况\n##### (1)引用赋值丢失\n```\nlet obj={\n    id :2,\n    foo:function(){\n        console.log(this);//Object[global]{}\n        console.log(this.id);\n    }\n};\nlet bar =obj.foo;\n\nbar();//undefined\n```\n\n##### (2)传参丢失\n```\nlet obj={\n    id :2,\n    foo:function(){\n        console.log(this);//Timeout{}\n        console.log(this.id);\n    }\n};\n\nsetTimeout(obj.foo,100);//undefined\n```\n##### (3)间接引用\n```\nlet obj1={\n    id :2,\n    bar:function (){\n        console.log(this.id);\n    }\n}\nlet obj2={\n    id :4,\n    baz:function (){\n        console.log(this.id);\n    }\n}\n\nobj1.bar();\nobj2.baz();\n(obj1.bar =obj2.baz)();//undefined\n```","tags":["js-this"],"categories":["js"]},{"title":"js循环闭包","url":"/2019/08/15/js基础/循环闭包/","content":"#### 循环闭包的原理\n##### 1.延迟函数的回调会在循环结束才执行（setTimeout是异步执行，当for循环结束后再执行回调函数）\n##### 2.五次循环被封闭在一个共享的全局作用域，实际上只有一个全局变量i\n\n```\nfor (var i=0;i<5;i++){\n    setTimeout(function timer() {\n        console.log(i),1000});\n}//5 5 5 5 5\n```\n##### 1.延迟函数的回调会在循环结束才执行（setTimeout是异步执行，当for循环结束后再执行回调函数）\n##### 2.五次循环被封闭在一个共享的全局作用域，实际上只有一个全局变量i\n```\nfor (let i=0;i<5;i++){\n    setTimeout(function timer() {\n        console.log(i),1000});\n}//0 1 2 3 4\n```\n```\n把var换成let，输出结果为0,1,2,3,4；\n1.因为let劫持了块作用域，每次迭代都会创建一个块作用域\n2.每次迭代都会重新声明i，用上一次迭代结束的值初始化这个变量\n```","tags":["循环闭包"],"categories":["js"]},{"title":"nodejs实现爬虫","url":"/2019/08/13/node/nodejs实现爬虫/","content":"#### node.js爬静态网页\n##### 封装函数(通过url访问服务器)\n    function GetUrl(sUrl,success){\n        let http ='';//把url转为url对象\n        let urlObj=url.parse(sUrl);//判断调用引入http模块/https模块\n        if (urlObj.protocol == 'http:'){\n            http =require('http');  }\n        else{   http =require('https'); }\n\n##### nodejs实现简单爬虫\n```\n    const fs =require('fs');\n    const url=require('url');\n    const JSDOM =require('jsdom').JSDOM;\n```\n###### 函数调用\n\n```\n    GetUrl('https://www.baidu.com/',data=>{\n\n        let DOM =new JSDOM(data);\n        let document =DOM.window.document;\n        let source =document.querySelector('#lg').children[0].src;\n        let oUrl ='https:'+source+'';\n        GetUrl(oUrl,data=>{\n            console.log(data);\n            fs.writeFile('a.jpg',data,()=> {\n                console.log(\"抓取成功\");\n            });\n        });\n\n    });\n```\n###### 封装函数(通过url访问服务器)\n\n```\n    function GetUrl(sUrl,success){\n        let http ='';\n        //把url转为url对象\n        let urlObj=url.parse(sUrl);\n        //判断调用引入http模块/https模块\n        if (urlObj.protocol == 'http:'){\n            http =require('http');\n        }\n        else{\n            http =require('https');\n        }\n        //访问服务器\n        let req =http.request({\n            'hostname':urlObj.hostname,\n            'path':urlObj.path\n        },res=>{\n            //判断重定向\n            if (res.statusCode==200){\n                let arr =[];\n                let str='';\n                //res.on('data',()=>{})node访问post数据\n                res.on('data',buffer=>{\n                    arr.push(buffer);\n                    str +=buffer;\n                });\n                //访问完成\n                res.on('end',()=>{\n                    //数据转为Buffer\n                    let b =Buffer.concat(arr);\n                    success && success(b);\n                });\n            }\n            else if(res.statusCode==302||res.statusCode==301){\n                //递归调用\n                GetUrl(res.headers.location,success);\n            }\n        });\n        req.end();\n        req.on(\"error\", ()=>{\n            console.log('404-not found');\n        })\n\n    }\n```\n","tags":["node.js"],"categories":["js"]},{"title":"js类型","url":"/2019/08/07/js基础/js类型/","content":"### js的类型基础\n#### js一共有7种内置类型分别是\nnull，undefined，boolean，string，\nnumber，object，symbol\n\n用typeof运算符可查看值的类型  返回的是一个字符串\n\n#### 特殊例子\n(js遗留下来的一个bug) typeof null = \"object\";\n另一种情况 typeof function(){} = \"function\";\n然而function并不是js的内置类型，function也是object(对象)\ntypeof [1,2] = \"object\"   数组也是object(对象)\n\n#### js 中变量是没有类型的，只有值才有类型\n\n```\n变量在未持有值的时候为undefined\n变量在未声明的时候会报ReferenceError错误\nlet a;\na;//undefined\nb;//ReferenceError b is not undefined (即undeclared未声明)\n```\n#### 安全检查全局变量是否已经被声明\n```\nif(typeof global!==\"undefined\"){\n    console.log(\"全局变量已声明\");\n}\n另一种方式通过浏览器的全局对象window\nif(window.global){\n    console.log(\"全局变量已声明\");\n}\n```","tags":["js-type"],"categories":["js"]},{"title":"node读取表单并写入数据库2","url":"/2019/06/05/node/表单提交2/","content":"#### node读取表单并写入数据库2\n```\n//引入http，url,fs,queryString\n    let http = require(\"http\");\n    let url = require(\"url\");\n    let fs = require(\"fs\");\n    let queryString =require(\"querystring\");\n```\n```\n    //引入http，url,fs,queryString\n    let http = require(\"http\");\n    let url = require(\"url\");\n    let fs = require(\"fs\");\n    let queryString =require(\"querystring\");\n    let mongodb=require(\"./dataBase\");\n    //创建服务  request response\n    let server =http.createServer((req,res)=>{\n        if(req.url===\"/postData\" && req.method.toLowerCase()===\"post\"){\n            let allData =\"\";\n            //nodejs用req.on(data)接收客户端的数据\n            req.on(\"data\",(buf)=>{\n                allData +=buf;\n            });\n            req.once(\"end\",()=>{\n                res.end(\"OK!\");\n                //将字符串转成对象。说白了其实就是把url上带的参数串转成数组对象。\n                let dataObj = queryString.parse(allData);\n                //创建data.txt\n                let fd =fs.open(\"data.txt\",\"w\",(err,fd)=>{\n                    if(!err){\n                        //写入data.txt\n                        fs.writeFile(fd,[dataObj.name,dataObj.password],(err)=>{\n                            if(!err){\n```\n#### 数据库操作\n```\n                                //写入数据库\n                                let data = fs.readFileSync(\"data.txt\",\"utf-8\");\n                                console.log(data);\n                                let arr = data.split(\",\");\n                                console.log(arr);\n                                //增加\n                                mongodb.create([\n                                    {name:arr[0],password: arr[1]}\n                                ],(err)=>{\n                                    if (!err){\n                                        console.log(\"插入成功\");\n                                    }  else{\n                                        throw err;\n                                    }\n                                });\n                                //查询\n                                mongodb.find({},{name:1,password:1,_id:0},(err,docs)=>{\n                                    console.log(\"开始查询\");\n                                    console.log(docs);\n                                    console.log(\"查询完成\");\n                                    if (!err){\n                                        //将docs转换成JSON\n                                        let datas = JSON.stringify(docs);\n                                        let fd =fs.open(\"test.json\",\"w\",(err,fd)=>{\n                                            if(!err){\n                                                //写入\n                                                fs.writeFile(fd,[datas],(err)=>{\n                                                    if(!err){\n                                                        console.log(\"写入成功\");\n                                                    }else{\n                                                        throw err;\n                                                    }\n                                                    fs.close(fd,(err)=>{\n                                                        if (!err){\n                                                            console.log(\"文件已经保存\");\n                                                        }else{\n                                                            throw err;\n                                                        }\n                                                    })\n                                                });\n                                            }else{\n                                                throw err;\n                                            }\n\n                                        });\n                                    }else{\n                                        throw  err;\n                                    }\n                                });\n```\n\n#### 数据库操作\n\n```\n\n                                console.log(\"写入成功\");\n                            }else{\n                                throw err;\n                            }\n                            fs.close(fd,(err)=>{\n                                if (!err){\n                                    console.log(\"文件已经保存\");\n                                }else{\n                                    throw err;\n                                }\n                            })\n                        });\n                    }else{\n                        throw err;\n                    }\n                });\n            });\n        }\n    }).listen(80,\"127.0.0.1\");\n\n```\n#### 数据库\n```\n    let fs =require(\"fs\");\n    let  mongoose =require(\"mongoose\");\n    mongoose.connect(\"mongodb://localhost/m_data\",{useNewUrlParser: true});\n    mongoose.connection.once(\"open\",()=>{\n        console.log(\"数据库连接成功\");\n    });\n    //创建Schema(模式对象)\n    let Schema =mongoose.Schema;\n    let  personSchema =new Schema({\n        name :String,\n        password:String\n    });\n    //创建Model对象\n    let personModel =mongoose.model(\"person\",personSchema);\n\n    module.exports=personModel;\n```","tags":["node.js"],"categories":["js"]},{"title":"node表单读取与数据库存储","url":"/2019/06/02/node/表单提交1/","content":"#### node读取表单并写入数据库\n ```\n //引入http，url,fs,queryString\n    let http = require(\"http\");\n    let url = require(\"url\");\n    let fs = require(\"fs\");\n    let queryString =require(\"querystring\");\n    //创建服务  request response\n```\n#### html部分\n```\n    <form id=\"register\" action=\"http://127.0.0.1/postData\" method=\"post\">\n        <p>用户名<input type=\"text\" id=\"oName\" name=\"name\"  ><br></p>\n        <p>密码<input type=\"password\" id=\"oPassword\" \n        name=\"password\"><br></p>\n        <p><input type=\"submit\" value=\"提交\"></p>\n    </form>\n```\n\n#### nodejs部分\n\n```\n    //引入http，url,fs,queryString\n    let http = require(\"http\");\n    let url = require(\"url\");\n    let fs = require(\"fs\");\n    let queryString =require(\"querystring\");\n    //创建服务  request response\n    let server =http.createServer((req,res)=>{\n        if(req.url===\"/postData\" && req.method.toLowerCase()===\"post\"){\n            let allData =\"\";\n            //nodejs用req.on(data)接收客户端的数据\n            req.on(\"data\",(buf)=>{\n                allData +=buf;\n            });\n            \n            req.once(\"end\",()=>{\n                res.end(\"OK!\");\n                //将字符串转成对象。说白了其实就是把url上带的参数串转成数组对象。\n                let dataObj = queryString.parse(allData);\n                console.log(dataObj);\n                console.log(dataObj.name);\n                console.log(dataObj.password);\n                //创建data.txt\n                let fd =fs.open(\"data.txt\",\"w\",(err,fd)=>{\n                    if(!err){\n                        //写入\n                        fs.writeFile(fd,[dataObj.name,dataObj.password],(err)=>{\n                            if(!err){\n```\n\n#### 数据库操作部分\n\n```\n\n                        //连接数据库\n                        let  mongoose =require(\"mongoose\");\n                        mongoose.connect(\"mongodb://localhost/m_data\",{useNewUrlParser: true});\n                        mongoose.connection.once(\"open\",()=>{\n                            console.log(\"数据库连接成功\");\n                        });\n                        //创建Schema(模式对象)\n                        let Schema =mongoose.Schema;\n                        let  personSchema =new Schema({\n                            name :String,\n                            password:String\n                        });\n                        //创建Model对象\n                        let personModel =mongoose.model(\"person\",personSchema);\n\n                        //同步读取文件\n                        let data = fs.readFileSync(\"data.txt\",\"utf-8\");\n                        console.log(data);\n\n                        let arr = data.split(\",\");\n                        console.log(arr);\n\n                        //增加\n                        personModel.create([\n                            {name:arr[0],password: arr[1]}\n\n                        ],(err)=>{\n                            if (!err){\n                                console.log(\"插入成功\");\n                            }  else{\n                                throw err;\n                            }\n                        });\n```\n\n```\n\n                                console.log(\"写入成功\");\n                            }else{\n                                throw err;\n                            }\n                            fs.close(fd,(err)=>{\n                                if (!err){\n                                    console.log(\"文件已经保存\");\n                                }else{\n                                    throw err;\n                                }\n                            })\n                        });\n                    }else{\n                        throw err;\n                    }\n                });\n            });\n        }\n    }).listen(80,\"127.0.0.1\");\n```\n","tags":["node.js"],"categories":["js"]},{"title":"node写入文件","url":"/2019/05/16/node/node写入流/","content":"#### node.js写入文件\n```\n    //引入模块\n    let fs =require(\"fs\");\n    //创建写入流\n    let ws =fs.createWriteStream(\"question.txt\");\n    console.log(ws);\n    //打开通道\n    ws.once(\"open\", () => {\n        console.log(\"通道已经打开\");\n    });\n    ws.once(\"close\", () => {\n        console.log(\"通道已经关闭\");\n    });\n    //写入通道\n    ws.write(\"answer1\");\n    ws.write(\"answer2\");\n    //关闭通道\n    ws.end();\n```","tags":["node.js"],"categories":["js"]},{"title":"node同步/异步文件写入","url":"/2019/05/16/node/异步文件写入/","content":"#### node同步/异步文件写入\n```\n    同步\n    //导入fs 文件系统\n    let fs =require(\"fs\");\n    //打开一个文件，可写//没有则会创建\n    let fd =fs.openSync(\"aaa.txt\",\"w\");\n    //写入\n    // sync 为synchronization的缩写\n    // n.同时; 同时性; 同步; 同期[步]录音;\n    fs.writeFileSync(fd,\"今天天气晴朗\");\n    //保存并退出\n    异步\n    let fs = require(\"fs\");//导入fs 文件系统\n    //打开文件\n    fs.open(\"aaaaa.txt\", \"w\", (err, fd) => {\n        //判断出错\n        if (!err) {\n        //写入\n        fs.writeFile(fd, \"今天天气真好\", () => {\n            if (!err) {\n                console.log(\"写入文件成功\");\n            } else {\n                throw err;\n            }\n            //关闭文件\n            fs.close(fd,(err)=>{\n                if (!err){\n                    console.log(\"文件保存并关闭\");\n                }\n            });\n        });\n        } else {\n            throw err;\n        }\n    });\n```","tags":["node"],"categories":["js"]}]