[{"title":"css垂直居中","date":"2020-04-02T06:49:47.347Z","path":"2020/04/02/css/垂直居中/","text":"垂直居中的方式(块级元素)1.绝对定位1.1 绝对定位+margin123456789div&#123; position: absolute; top: 0; left: 0; bottom: 0; right: 0; height: 200px; width: 200px; background-color: #232323; /*水平垂直居中*/ margin: auto;&#125; 12345678910div&#123; position: absolute; top: 0; left: 0; bottom: 0; right: 0; height: 200px; width: 200px; background-color: #232323; /*垂直居中*/ margin-top:auto; margin-bottom: auto;&#125; 12345原理:1.在普通内容流中，margin:auto的效果等同于margin-top:0;margin-bottom:0。2.position:absolute使绝对定位块跳出了内容流，内容流中的其余部分渲染时绝对定位部分不进行渲染。3.为块区域设置top: 0; left: 0; bottom: 0; right: 0;将给浏览器重新分配一个边界框，此时该块块将填充其父元素的所有可用空间，所以margin 垂直方向上有了可分配的空间。4.再设置margin 垂直方向上下为auto，即可实现垂直居中。（注意高度得设置）。 1.2 绝对定位+top+left123456789div&#123; position: absolute; height: 200px; width: 200px; background-color: #232323; top: 50%; left: 50%; transform: translate(-50%,-50%);&#125; 2.弹性布局display:flex12345678div&#123; height: 600px; width: 600px; border: 1px solid black; margin: 0 auto; display: flex; align-items: center; &#125; 3.display:table此元素会作为块级表格来显示（类似 ），表格前后带有换行符。12345678910div&#123; display: table; height: 200px; width: 200px; background-color: #232323; vertical-align: center;&#125;vertical-align该属性定义行内元素的基线相对于该元素所在行的基线的垂直对齐。允许指定负长度值和百分比值。这会使元素降低而不是升高。在表单元格中，这个属性会设置单元格框中的单元格内容的对齐方式。 2.行内元素123456line-height = height行内元素特征：(1)设置宽高无效(2)对margin仅设置左右方向有效，上下无效；padding设置上下左右都有效，即会撑大空间(3)不会自动进行换行"},{"title":"hexo问题","date":"2020-04-01T15:26:31.527Z","path":"2020/04/01/hexo/hexo/","text":"hexo 的问题记录hexo发布后样式丢失修改配置中url路径，和root FATAL Something’s wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.htmlError: Spawn failed at ChildProcess. (E:\\STUDY\\hexo\\node_modules\\hexo-util\\lib\\spawn.js:52:19) at ChildProcess.emit (events.js:200:13) at ChildProcess.cp.emit (E:\\STUDY\\hexo\\node_modules\\cross-spawn\\lib\\enoent.js:40:29) at Process.ChildProcess._handle.onexit (internal/child_process.js:272:12) 删除 .deploy_git重新hexo c &amp;&amp;hexo g &amp;&amp; hexo d"},{"title":"Set和Map","date":"2020-04-01T06:42:23.380Z","path":"2020/04/01/js基础/set和map/","text":"创建Mapnew创建123Map是一组键值对的结构，具有极快的查找速度。let foo = new Map([[1, 10], [2, 20], [3, 30]]);Map传入的值必须是一个二维数组 初始化空Map12345678910let foo = new Map();foo.set(1,10);foo.get(1);foo.has(1)foo.delete(1)输出:Map &#123; 1 =&gt; 10 &#125;10truetrue 创建Setnew创建1234Set和Map类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在Set中，没有重复的key。let foo = new Set([1,2])Set传入一个数组Set &#123; 1, 2 &#125; 初始化空Set1234567let foo = new Set()foo.add(1)foo.delete(1)输出结果:Set &#123; 1 &#125;true Set Map 普通对象12341.普通对象的key值必须是stringMap,Set的key值可以是任意值2.Set只有key没有value3.key值不能重复"},{"title":"node基础","date":"2020-03-31T08:37:40.943Z","path":"2020/03/31/node/io/","text":"node.js基础整理I/OIO端口，I/O输入/输出(Input/Output)，分为IO设备和IO接口两个部分。每个设备都会有一个专用的I/O地址，用来处理自己的输入输出信息。I/O地址绝对不能重复，如果两个设备的I/O地址有冲突，系统硬件就不能正常工作。 node为什么选择jsjs没有自带的I/O，有良好的事件支持机制 模块模块化关键词require，exports，module#####1.1 require例:let foo = require(‘./bar.js’); 1.2 exports例:exports.hello = function () { console.log(“Hello World!”); } 1.3 module例:module.exports = function () { console.log(“Hello World!”); } 注释:exports是module.exports的引用module.exports既可以通过点语法，也可以直接赋值一个对象例:module.exports.xxx=xxxmodule.exports=xxx，exports只能用”.”例:exports.xxx=xxx #####"},{"title":"微信小程序","date":"2020-03-19T05:33:59.811Z","path":"2020/03/19/小程序/微信/","text":"微信小程序(开个坑) ####wx.navigateTo和wx.redirectTo的区别"},{"title":"call apply bind","date":"2020-03-14T08:04:12.838Z","path":"2020/03/14/js基础/call/","text":"call bind 和apply的异同点1. call和apply1call() 和apply()方法使用一个指定的 *this值* 和单独给出的一个或多个参数来调用一个函数。 123456789101112function Foo(name,age)&#123; this.name = name; this.age = age;&#125;function Bar(name,age,id)&#123; Foo.call(this,name,age); this.id = id;&#125;console.log(new Bar(&apos;张三&apos;,20,1001).name);console.log(new Bar(&apos;张三&apos;,20,1001).id);//张三//1001 2. 区别12apply(this值,[数组])call(this值,参数1,参数2,...) 3. 如果不设置第一个参数1234567es6默认严格模式，输出undefined，而不会指向全局对象let name = &apos;张三&apos;;function foo()&#123; console.log(this.name);&#125;foo.call();//undefined 4. bind12345bind() 方法创建一个新的函数，在 bind() 被调用时，这个新函数的 this 被指定为 bind()的第一个参数，而其余参数将作为新函数的参数，供调用时使用。 3.1 typeof (Foo.call(this, name, age))1234567891011function Foo(name,age)&#123; this.name = name; this.age = age;&#125;function Bar(name,age)&#123; Foo.call(this,name,age); console.log(typeof (Foo.call(this, name, age)));&#125;console.log(new Bar(&apos;张三&apos;,20).name);//undefined//张三 3.2 typeof (Foo.bind(this, name, age))123456789101112function Foo(name,age)&#123; this.name = name; this.age = age;&#125;function Bar(name,age)&#123; Foo.bind(this,name,age); console.log(typeof (Foo.bind(this, name, age))); (Foo.bind(this, name, age))();&#125;console.log(new Bar(&apos;张三&apos;,20).name);//function//张三"},{"title":"react学习记录","date":"2020-03-13T05:44:46.826Z","path":"2020/03/13/react/react学习/","text":"react学习记录(开个坑)"},{"title":"基础类型和引用类型","date":"2020-03-12T01:51:22.258Z","path":"2020/03/12/js基础/类型/","text":"基础类型和引用类型的区别js类型1. 基础类型12345number ,string,null，undefined，Boolean赋值的时候传递的是值变量名和值直接存在在栈内存中 2.引用类型12345678Object,Array,Function赋值的时候传递的是引用变量名(引用)存放在栈内存中，实际值存放在堆内存中原因:引用值的大小会改变，所以不能放在栈中，否则会降低变量查询的速度,当我们把引用类型传递给变量的时候，此时我们传递的是引用类型的地址"},{"title":"java数组","date":"2020-03-12T01:09:32.808Z","path":"2020/03/12/java/java数组/","text":"java数组的基础知识1. 数组的创建方式1234567891011数组的 声明类型[] 数组名 ;int[] arr;数组的 创建new 类型[数组大小];arr =new int[10];三种方式(1) int[] arr = new int[10];(2) int[] arr = &#123;1,2,3&#125;;(3) int[] arr = new int[]&#123;1,2,3&#125;; 2. 注意点123456789101.通过下标访问2.下标不能越界3.创建后大小固定，无法扩容或缩小3.每个元素的类型是一样的4.数组不是基本数据类型不能进行强制类型转换5.不兼容低精度数据赋值给高精度数据，但数组元素间支持6.没有赋值的数组int型默认值为0；char默认值为nul(invisible不可见),boolean默认值为false，String为null7.数组的数据类型不是基本数据类型的数组是引用类型 3. 数组的clone方法3.1 数组的数据类型为基础类型调用clone方法会返回一个新的数组注意点:使用clone方法的时候需要进行强制类型转换12int[] arr = &#123;1,2,3&#125;;int[] clonedArr = (int[]) arr.clone; 3.2 数组的数据类型不再是基本数据类型/*或者是多维数组的直接clone*1clone方法不会产生新的数组，而是生成一个指向数组的引用 3.3 多维数组的最后一层参照基础类型"},{"title":"迭代器","date":"2020-03-11T05:52:45.987Z","path":"2020/03/11/js基础/迭代器/","text":"迭代器的原理和工作方式1. Symbol.iterator 为每一个对象定义了默认的迭代器。该迭代器可以被 for…of 循环使用，和 …运算符 操作。1.1 Object身上没有Symbol.iterator，直接使用时会报undefined123let obj =&#123;&#125;console.log(obj[Symbol.iterator]);//udefined 1234567let foo =&#123; &apos;bar&apos;:1, &apos;baz&apos;:2&#125;for (let v of foo)&#123; console.log(v);&#125;//TypeError: foo is not iterable 1.2 Array自带Symbol.iterator123let arr=[];console.log(arr[Symbol.iterator]());//Object [Array Iterator] &#123;&#125; 1.3 两种相同的声明方式123456789101112131415let foo1 =&#123; &apos;bar&apos;:function()&#123; console.log(1); &#125;&#125;console.log(foo1[&apos;bar&apos;]());//1let foo2 =&#123; [&apos;bar&apos;]:function()&#123; console.log(2); &#125;&#125;console.log(foo2[&apos;bar&apos;]());//2 *生成器本身不是迭代器，当你执行生成器的时候就能得到一个迭代器*生成器在yield处暂停 ，生成器的状态会被保持1.4 obj实现for ofES6 同时提供了 Symbol.iterator 属性，只要一个对象有这个属性，就会被视为有 Iterator 接口123456789101112131415161718192021222324252627282930let foo =&#123; &apos;bar&apos;:1, &apos;baz&apos;:2&#125;foo[Symbol.iterator] = function()&#123; let index = 0, self = this, keys = Object.keys( self ); return &#123; next()&#123; if( index &lt; keys.length )&#123; return &#123; value: self[keys[index++]], done: false &#125;; &#125; else&#123; return &#123; value: undefined , done: true &#125; &#125; &#125; &#125;&#125;for (let v of foo)&#123; console.log(v);&#125;"},{"title":"生成器","date":"2020-03-11T05:03:23.130Z","path":"2020/03/11/js基础/生成器/","text":"生成器的运作方式和原理1. 功能：打破完整的函数运行。函数运行到断点yield处会停止运行，用迭代器.next()来控制一步步往下运行，同时函数不再只有一个返回值123456789101112131415161718192021222324function* foo() &#123; let x = yield 2; console.log(x); let y = yield (x * 2); console.log(y); &#125; let it = foo(); console.log(it.next()); console.log(it.next(20)); console.log(it.next(1000)); 输出结果： 2， 20， 40， 1000， &#123; value: undefined, done: true &#125;//在yield处设置断点，第一个.next()用于启动生成器，不传入值；然后yield会将其后面的值当作返回值返回，运行到第二个.next()，传入20，用20这个值赋值给 x 输出x的值20；并继续运行到下个yield，下个yield会将x*2的值返回；运行到第三个.next()传入1000并赋值给 y 输出y的值1000函数默认返回undefined,done true表示迭代结束"},{"title":"git代理","date":"2020-02-25T09:02:26.438Z","path":"2020/02/25/git/代理/","text":"github设置代理设置ss123git config --global http.proxy &apos;socks5://127.0.0.1:1080&apos;git config --global https.proxy &apos;socks5://127.0.0.1:1080&apos; 设置代理123git config --global https.proxy http://127.0.0.1:1080git config --global https.proxy https://127.0.0.1:1080 取消代理123git config --global --unset http.proxygit config --global --unset https.proxy"},{"title":"回调","date":"2020-02-24T11:28:23.723Z","path":"2020/02/24/js基础/回调/","text":"1. 回调函数和普通函数的区别1.1 普通函数：调用程序发出对普通函数的调用后，程序执行立即转向被调用函数执行，直到(被调用函数)执行完毕后，再返回调用程序继续执行。*程序调用普通函数–&gt;等待被调用函数执行完毕–&gt;继续执行程序 1.2 回调函数：（Callback）调用程序发出对回调函数的调用后，不等函数执行完毕，立即返回并继续执行。被调用函数进入循环队列。当被调函数执行完毕后，被调函数会反过来调用某个事先指定函数，以通知调用程序：函数调用周期结束，这个过程称为回调。 2.定时器2.1 node提供了四个定时器1234setTimeout()setInterval()setImmediate()process.nextTick() 2.2 速度对比12345678910111213setTimeout(() =&gt; console.log(1));setInterval(() =&gt; console.log(2));setImmediate(() =&gt; console.log(3));process.nextTick(() =&gt; console.log(4));Promise.resolve().then(() =&gt; console.log(5));(() =&gt; console.log(6))();结果： 6-&gt;4-&gt;5-&gt;1-&gt;2-&gt;3先执行同步的(() =&gt; console.log(6))();然后执行process.nextTick(() =&gt; console.log(4));process.nextTick是定时器中速度最快的然后执行Promise.resolve().then(() =&gt; console.log(5));promise的速度仅次于process.nextTick 123456789101112131415161718192021222324setInterval(() =&gt; console.log(2));setImmediate(() =&gt; console.log(3));setTimeout(() =&gt; console.log(1));//3-&gt;2-&gt;1setImmediate(() =&gt; console.log(3));setTimeout(() =&gt; console.log(1));setInterval(() =&gt; console.log(2));//3-&gt;1-&gt;2setTimeout(() =&gt; console.log(1));setInterval(() =&gt; console.log(2));setImmediate(() =&gt; console.log(3));//1-&gt;2-&gt;3setInterval(() =&gt; console.log(2));setTimeout(() =&gt; console.log(1));setImmediate(() =&gt; console.log(3));//2-&gt;3-&gt;1setImmediate(() =&gt; console.log(3));setInterval(() =&gt; console.log(2));setTimeout(() =&gt; console.log(1));//3-&gt;2-&gt;1setTimeout(() =&gt; console.log(1));setImmediate(() =&gt; console.log(3));setInterval(() =&gt; console.log(2));//3-&gt;1-&gt;2 2.3 总结: setInterval，setImmediate，setTimeout没有绝对的快慢"},{"title":"散列表冲突解决之分离链接","date":"2019-09-19T08:21:30.861Z","path":"2019/09/19/基于js的数据结构与算法/散列表冲突解决分离链接/","text":"js散列表冲突解决分离链接方式123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154class HashTableSeparateChaining &#123; constructor(toStrFn=defaultToString)&#123; this.toStrFn =toStrFn; this.table=&#123;&#125;; &#125;; &#125;//确保键一定是字符串let defaultToString=function defaultToString(item) &#123; if (item===null)&#123; return &quot;NULL&quot;; &#125;else if (item ===undefined)&#123; return &quot;UNDEFINED&quot;; // instanceof运算符用于测试构造函数的prototype属性是否出现在对象的原型链中的任何位置 &#125;else if (typeof item===&quot;string&quot;||item instanceof String)&#123; return `$&#123;item&#125;`; &#125; return item.toString();&#125;class ValuePair &#123; constructor(key,value)&#123; this.key =key; this.value=value; &#125; toString()&#123; return `[#$&#123;this.key&#125;:$&#123;this.value&#125;]`; &#125;&#125;//创建散列表(链式)class HashTableSeparateChaining &#123; constructor(toStrFn=defaultToString)&#123; this.toStrFn =toStrFn; this.table=&#123;&#125;; &#125;; //散列函数 loseloseHashCode(key)&#123; if (typeof key===&apos;number&apos;)&#123; return key; &#125; //转key为字符串 const tableKey =this.toStrFn(key); let hash =0; //charCodeAt() 方法可返回指定位置的字符的 Unicode 编码。 for (let i=0;i&lt;tableKey.length;i++)&#123; hash +=tableKey.charCodeAt(i); &#125; return hash %37; &#125; hashCode(key)&#123; return this.loseloseHashCode(key); &#125;; //向散列表增加一个新项 put(key,value)&#123; if(key !=null &amp;&amp; value !=null)&#123; //获取hashCode const position =this.hashCode(key); if (this.table[position] == null)&#123; this.table[position] =new LinkedList(); &#125; this.table[position].push(new ValuePair(key,value)); return true; &#125; return false; &#125;; //从散列表获取一个值 get(key)&#123; const position =this.hashCode(key); const linkedList =this.table[position]; if (linkedList !=null &amp;&amp;!linkedList.isEmpty())&#123; let current =linkedList.getHead(); while(current !=null)&#123; if (current.element.key===key) &#123; return current.element.value; &#125; current =current.next; &#125; &#125; return undefined; &#125;; //从散列表中移除一个值 remove(key) &#123; const position = this.hashCode(key); const linkedList =this.table[position]; if (linkedList !=null &amp;&amp;linkedList.isEmpty())&#123; let current =linkedList.getHead(); while(current !=null)&#123; if (current.element.key===key)&#123; linkedList.remove(current.element); if (linkedList.isEmpty())&#123; delete this.table[position]; &#125; return true; &#125; current =current.next; &#125; &#125; return false; &#125;; //toString方法 toString()&#123; if (this.isEmpty())&#123; return &apos;&apos;; &#125; const keys =Object.keys(this.table); let objString =`&#123;$&#123;keys[0]&#125;=&gt;$&#123;this.table[keys[0]].toString()&#125;&#125;`; for (let i=1;i&lt;keys.length;i++)&#123; objString =`$&#123;objString&#125;,&#123;$&#123;keys[i]&#125;=&gt;$&#123;this.table[keys[i]].toString() &#125;&#125;`; &#125; return objString; &#125;; //size方法 size()&#123; return Object.keys(this.table).length; &#125; //isEmpty方法 isEmpty()&#123; return this.size()===0; &#125;&#125;const hash =new HashTableSeparateChaining();hash.put(&apos;aaa&apos;,&apos;aaa@qq.com&apos;);hash.put(&apos;bbb&apos;,&apos;bbb@qq.com&apos;);hash.put(&apos;ccc&apos;,&apos;ccc@qq.com&apos;);// console.log(hash);console.log(hash.table);console.log(hash.toString());// console.log(hash.size());// console.log(hash.isEmpty());// console.log(hash.hashCode(&apos;aaa&apos;) + &apos;-aaa&apos;);// console.log(hash.hashCode(&apos;bbb&apos;) + &apos;-bbb&apos;);// console.log(hash.hashCode(&apos;ccc&apos;) + &apos;-ccc&apos;);// console.log(hash.get(&apos;aaa&apos;));// console.log(hash.get(&apos;ddd&apos;));//// hash.remove(&apos;aaa&apos;);// console.log(hash.get(&apos;aaa&apos;));"},{"title":"js散列表冲突解决线性探查","date":"2019-09-19T08:21:25.803Z","path":"2019/09/19/基于js的数据结构与算法/散列表冲突解决线性探查/","text":"散列表冲突解决线性探查方式123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179class HashTableSeparateChaining &#123; constructor(toStrFn=defaultToString)&#123; this.toStrFn =toStrFn; this.table=&#123;&#125;; &#125;;&#125;//确保键一定是字符串let defaultToString=function defaultToString(item) &#123; if (item===null)&#123; return &quot;NULL&quot;; &#125;else if (item ===undefined)&#123; return &quot;UNDEFINED&quot;; // instanceof运算符用于测试构造函数的prototype属性是否出现在对象的原型链中的任何位置 &#125;else if (typeof item===&quot;string&quot;||item instanceof String)&#123; return `$&#123;item&#125;`; &#125; return item.toString();&#125;class ValuePair &#123; constructor(key,value)&#123; this.key =key; this.value=value; &#125; toString()&#123; return `[#$&#123;this.key&#125;:$&#123;this.value&#125;]`; &#125;&#125;//创建散列表class HashTableSeparateChaining &#123; constructor(toStrFn=defaultToString)&#123; this.toStrFn =toStrFn; this.table=&#123;&#125;; &#125;; //散列函数 loseloseHashCode(key)&#123; if (typeof key===&apos;number&apos;)&#123; return key; &#125; //转key为字符串 const tableKey =this.toStrFn(key); let hash =0; //charCodeAt() 方法可返回指定位置的字符的 Unicode 编码。 for (let i=0;i&lt;tableKey.length;i++)&#123; hash +=tableKey.charCodeAt(i); &#125; return hash %37; &#125; hashCode(key)&#123; return this.loseloseHashCode(key); &#125;; //移动冲突元素的辅助函数 verifyRemoveSideEffect(key, removePosition) &#123; const hash =this.hashCode(key); let index =removePosition+1; while(this.table[index] !=null)&#123; const posHash =this.hashCode(this.table[index].key); //hash为原始值 removePosition上一个被移除key的hash值 if (posHash&lt;=hash ||posHash &lt;=removePosition)&#123; this.table[removePosition]=this.table[index]; delete this.table[index]; removePosition =index; &#125; index++; &#125; &#125;; //向散列表增加一个新项 put(key,value)&#123; if (key !=null &amp;&amp; value !=null)&#123; const position =this.hashCode(key); if (this.table[position]==null)&#123; this.table[position]=new ValuePair(key,value); &#125; else&#123; let index =position +1; while(this.table[index] !=null)&#123; index++; &#125; this.table[index] =new ValuePair(key,value); &#125; return true; &#125; return false; &#125;; //从散列表获取一个值 get(key)&#123; const position =this.hashCode(key); if (this.table[position] !=null)&#123; if (this.table[position].key ===key)&#123; return this.table[position].value; &#125; let index =position +1; while(this.table[index]!=null &amp;&amp;this.table[index].key !=key)&#123; index++; &#125; if (this.table[index]!=null &amp;&amp;this.table[index].key ===key)&#123; return this.table[position].value; &#125; &#125; return undefined; &#125;; //从散列表中移除一个值 remove(key) &#123; const position =this.hashCode(key); if (this.table[position]!=null)&#123; if (this.table[position].key ===key)&#123; delete this.table[position]; this.verifyRemoveSideEffect(key,position); return true; &#125; let index =position+1; while(this.table[index] !=null &amp;&amp;this.table[index].key !==key)&#123; index++; &#125; if (this.table[index] !=null &amp;&amp;this.table[index].key===key)&#123; delete this.table[index]; this.verifyRemoveSideEffect(key,index); return true; &#125; &#125; return false; &#125;; //toString方法 toString()&#123; if (this.isEmpty())&#123; return &apos;&apos;; &#125; const keys =Object.keys(this.table); let objString =`&#123;$&#123;keys[0]&#125;=&gt;$&#123;this.table[keys[0]].toString()&#125;&#125;`; for (let i=1;i&lt;keys.length;i++)&#123; objString =`$&#123;objString&#125;,&#123;$&#123;keys[i]&#125;=&gt;$&#123;this.table[keys[i]].toString() &#125;&#125;`; &#125; return objString; &#125;; //size方法 size()&#123; return Object.keys(this.table).length; &#125; //isEmpty方法 isEmpty()&#123; return this.size()===0; &#125;&#125;const hash =new HashTableSeparateChaining();hash.put(&apos;aaa&apos;,&apos;aaa@qq.com&apos;);hash.put(&apos;bbb&apos;,&apos;bbb@qq.com&apos;);hash.put(&apos;ccc&apos;,&apos;ccc@qq.com&apos;);// console.log(hash);console.log(hash.table);console.log(hash.toString());// console.log(hash.size());// console.log(hash.isEmpty());// console.log(hash.hashCode(&apos;aaa&apos;) + &apos;-aaa&apos;);// console.log(hash.hashCode(&apos;bbb&apos;) + &apos;-bbb&apos;);// console.log(hash.hashCode(&apos;ccc&apos;) + &apos;-ccc&apos;);// console.log(hash.get(&apos;aaa&apos;));// console.log(hash.get(&apos;ddd&apos;));//// hash.remove(&apos;aaa&apos;);// console.log(hash.get(&apos;aaa&apos;));"},{"title":"集合","date":"2019-09-19T08:16:17.155Z","path":"2019/09/19/基于js的数据结构与算法/集合/","text":"集合的原理与实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167class Set &#123; constructor()&#123; this.items=&#123;&#125;; &#125;; //实现集合的基础//js对向像一个键指向两个不同的属性，保证集合元素的唯一 &#125;//集合(表示一组互(不重复)不相同的元素)存储方式[值，值]class Set &#123; constructor()&#123; this.items=&#123;&#125;; &#125;; //实现集合的基础//js对向像一个键指向两个不同的属性，保证集合元素的唯一 //has element方法 //1.使用js的in方法(返回表示对象在原型链上是否具有特定属性的布尔值) has(element)&#123; return element in items; &#125;; //2.原型链hasOwnProperty方法(返回一个表明对象是否有特定属性的布尔值)(安全做法) has (element)&#123; return Object.prototype.hasOwnProperty.call(this.items,element); &#125;; //添加一个元素//同时作为剪纸保存，便于查找 add(element)&#123; if (!this.has(element))&#123; this.items[element]=element; return true; &#125; return false; &#125;; //delete 方法 delete(element)&#123; if (this.has(element))&#123; delete this.items[element]; return true; &#125; return false; &#125;; //clear方法 clear()&#123; this.items =&#123;&#125;; &#125;; //size方法 //方法一：利用一个length变量记录 //方法二： //利用Object的keys方法(返回一个包含给定对象所有属性的数组) //方法三：手动提取items变量的每一个属性 size()&#123; return Object.keys(this.items).length; &#125;; //方法三：手动提取items变量的每一个属性 sizeLegacy()&#123; let count=0; //for in 遍历会遍历原型链 for(let key in this.items)&#123; if (this.items.hasOwnProperty(key))&#123; count++; &#125; return count; &#125; &#125;; //values方法(内置方法) values()&#123; return Object.values(this.items); &#125;; //手动遍历 valuesLegacy()&#123; let values=[]; for (let key in this.items)&#123; if (this.items.hasOwnProperty(key))&#123; values.push(key); &#125; &#125; return values; &#125;; //集合运算 // 并集 union(otherSet)&#123; const unionSet =new Set(); let values =this.values(); for (let i=0;i&lt;values.length;i++)&#123; unionSet.add(values[i]); &#125; values =otherSet.values(); for (let i=0;i&lt;values.length;i++)&#123; unionSet.add(values[i]); &#125; return unionSet; &#125;; //交集 intersection(otherSet)&#123; const intersectionSet =new Set(); const values =this.values(); for (let i=0; i&lt;values.length;i++) &#123; if (otherSet.has(values[i]))&#123; intersectionSet.add(values[i]); &#125; &#125; return intersectionSet; &#125;; intersection(otherSet)&#123; const intersectionSet =new Set(); const values=this.values(); const otherValues=otherSet.values(); let biggerSet =values; let smallerSet=otherValues; if (otherValues.length -values.length &gt;0)&#123; biggerSet =otherValues; smallerSet =values; &#125; smallerSet.forEach(value =&gt;&#123; if (biggerSet.includes(value))&#123; intersectionSet.add(value); &#125; &#125;); return intersectionSet; &#125;; //差集 difference(otherSet)&#123; const differenceSet =new Set(); this.values().forEach(value=&gt;&#123; if(!otherSet.has(value))&#123; differenceSet.add(value); &#125; &#125;); return differenceSet; &#125;; //子集 isSubsetOf(otherSet)&#123; if (this.size()&gt;otherSet.size())&#123; return false; &#125; //返回false,every循环结束 let isSubset =true; this.values().every(value=&gt;&#123; if (!otherSet.has(value))&#123; isSubset=false; return false; &#125; return true; &#125;); return isSubset; &#125;&#125;//测试用例const set =new Set();set.add(1);set.add(2);console.log(set);"},{"title":"js字典","date":"2019-09-19T08:13:14.017Z","path":"2019/09/19/基于js的数据结构与算法/字典/","text":"构造字典123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171class Dictionary &#123; //构造函数 constructor(toStrFn =defaultToString)&#123; this.toStrFn =toStrFn; this.table =&#123;&#125;; &#125;; &#125;//确保键一定是字符串let defaultToString=function defaultToString(item) &#123; if (item===null)&#123; return &quot;NULL&quot;; &#125;else if (item ===undefined)&#123; return &quot;UNDEFINED&quot;; // instanceof运算符用于测试构造函数的prototype属性是否出现在对象的原型链中的任何位置 &#125;else if (typeof item===&quot;string&quot;||item instanceof String)&#123; return `$&#123;item&#125;`; &#125; return item.toString();&#125;//字典中每个键只有一个值，以[键，值]形式存储元素// import defaultToString from &apos;./util&apos;;// **// export与export default均可用于导出常量、函数、文件、模块等// 2、你可以在其它文件或模块中通过import+(常量 | 函数 | 文件 | 模块)名的方式，将其导入，以便能够对其进行使用// 3、在一个文件或模块中，export、import可以有多个，export default仅有一个//valuePair类class ValuePair &#123; constructor(key,value)&#123; this.key =key; this.value=value; &#125; toString()&#123; return `[#$&#123;this.key&#125;:$&#123;this.value&#125;]`; &#125;&#125;// 4、通过export方式导出，在导入时要加&#123; &#125;，export default则不需要class Dictionary &#123; //构造函数 constructor(toStrFn =defaultToString)&#123; this.toStrFn =toStrFn; this.table =&#123;&#125;; &#125;; //检测一个键是否存在于字典中 //js只允许我们使用字符串作为对象的键名和属性名 hasKey(key)&#123; return this.table[this.toStrFn(key)] !=null; &#125; //set方法 set(key,value)&#123; if (key !=null &amp;&amp; value !=null)&#123; const tableKey =this.toStrFn(key); this.table[tableKey] =new ValuePair(key,value); return true; &#125; return false; &#125;; //remove方法 remove(key)&#123; if (this.hasKey(key))&#123; delete this.table[this.toStrFn(key)]; return true; &#125; return false; &#125;; //检索一个值get方法 get(key)&#123; const valuePair =this.table[this.toStrFn(key)]; return valuePair ==null ?undefined :valuePair.value; &#125;; //keyValues方法\\ //方法一 keyValues()&#123; return Object.values(this.table); &#125; //方法二 keyValues()&#123; const valuePairs =[]; for (const k in this.table)&#123; if (this.hasKey(k))&#123; valuePairs.push(this.table[k]); &#125; &#125; return valuePairs; &#125;; //keys方法 keys()&#123; return this.keyValues().map(valuePair =&gt;&#123; return valuePair.key &#125;); &#125;; //方法二 // keys()&#123; // const keys=[]; // const valuePairs =this.keyValues(); // for (let i=0;i&lt;valuePairs.length;i++)&#123; // keys.push(valuePairs[i].key); // &#125; // return keys; // &#125;; values()&#123; return this.keyValues().map(valuePair =&gt; &#123; return valuePair.value; &#125;); &#125;; //方法二 // values()&#123; // const values=[]; // const valuePairs =this.keyValues(); // for (let i=0;i&lt;valuePairs.length;i++)&#123; // values.push(valuePairs[i].value); // &#125; // return values; // &#125;; //forEach forEach(callbackFn)&#123; const valuePairs =this.keyValues(); for (let i=0;i&lt;valuePairs.length;i++)&#123; const result =callbackFn(valuePairs[i].key,valuePairs[i].value); if (result===false)&#123; break; &#125; &#125; &#125;; //size方法 size()&#123; return Object.keys(this.table).length; // return this.keyValues().length; &#125;; //isEmpty方法 isEmpty()&#123; return this.size()===0; &#125;; //clear方法 clear()&#123; return this.table=&#123;&#125;; &#125;; //toString方法 toString()&#123; if (this.isEmpty())&#123; return &quot;&quot;; &#125; const valuePairs =this.keyValues(); let objString =`$&#123;valuePairs[0].toString()&#125;`; for (let i=1;i&lt;valuePairs.length;i++)&#123; objString=`$&#123;objString&#125;,$&#123;valuePairs[i].toString()&#125;`; &#125; return objString; &#125;;&#125;//测试const dictionary =new Dictionary();dictionary.set(&apos;aaaa&apos;,&quot;afdafad&quot;);dictionary.set(&apos;bbbb&apos;,&quot;dfadfaf&quot;);dictionary.set(&apos;cccc&apos;,&quot;ddsdffd&quot;);console.log(dictionary.hasKey(&apos;aaaa&apos;));console.log(dictionary.size());console.log(dictionary.get(&apos;aaaa&apos;));// console.log(dictionary);console.log(dictionary.toString());dictionary.forEach((k,v)=&gt;&#123; console.log(&apos;forEach:&apos;, `key:$&#123;k&#125;,value:$&#123;v&#125;`);&#125;) ;console.log(dictionary.keyValues());console.log(dictionary.values());console.log(dictionary.keys());"},{"title":"this绑定规则","date":"2019-08-15T06:36:04.810Z","path":"2019/08/15/js基础/this绑定规则/","text":"js中this的绑定规则绑定规则1.默认绑定1234567this的默认绑定指向全局变量function foo()&#123; console.log(this.a);&#125;let a=2;foo(); 2.隐式绑定12345678910调用位置的上下文对象（被某个对象拥有或者包含）function foo()&#123; console.log(this.a);&#125;let obj =&#123; a:2, foo:foo&#125;obj.foo();//2 3.显式绑定123456789使用call()和apply()方法function foo()&#123; console.log(this.a);&#125;let obj=&#123; a:2&#125;foo.call(obj);//2 普通的显式绑定无法解决隐式丢失问题(1)硬绑定 使用bind()方法能解决this隐式丢失的问题12345678910function foo()&#123; console.log(this.a); return this.a;&#125;let obj =&#123; a:2&#125;let bar =foo.bind(obj);console.log(2);//2 4.new绑定1234567891011使用new来调用函数会执行下面的操作（1）创建一个全新的对象（2）这个对象会被执行原型链连接（3）这个对象会绑定到函数调用的this（4）如果函数没有其他返回对象，new表达式中的函数就会自动返回这个新对象function foo(a)&#123; this.a=a;&#125;let bar =new foo(2);console.log(bar.a);//2 优先级 new绑定&gt;显式绑定&gt;隐式绑定&gt;默认绑定"},{"title":"js隐式丢失this绑定的情况","date":"2019-08-15T04:15:42.370Z","path":"2019/08/15/js基础/this隐式丢失/","text":"隐式丢失this绑定的情况(1)引用赋值丢失12345678910let obj=&#123; id :2, foo:function()&#123; console.log(this);//Object[global]&#123;&#125; console.log(this.id); &#125;&#125;;let bar =obj.foo;bar();//undefined (2)传参丢失123456789let obj=&#123; id :2, foo:function()&#123; console.log(this);//Timeout&#123;&#125; console.log(this.id); &#125;&#125;;setTimeout(obj.foo,100);//undefined (3)间接引用12345678910111213141516let obj1=&#123; id :2, bar:function ()&#123; console.log(this.id); &#125;&#125;let obj2=&#123; id :4, baz:function ()&#123; console.log(this.id); &#125;&#125;obj1.bar();obj2.baz();(obj1.bar =obj2.baz)();//undefined"},{"title":"js循环闭包","date":"2019-08-15T03:03:49.721Z","path":"2019/08/15/js基础/循环闭包/","text":"循环闭包的原理1.延迟函数的回调会在循环结束才执行（setTimeout是异步执行，当for循环结束后再执行回调函数）2.五次循环被封闭在一个共享的全局作用域，实际上只有一个全局变量i1234for (var i=0;i&lt;5;i++)&#123; setTimeout(function timer() &#123; console.log(i),1000&#125;);&#125;//5 5 5 5 5 1.延迟函数的回调会在循环结束才执行（setTimeout是异步执行，当for循环结束后再执行回调函数）2.五次循环被封闭在一个共享的全局作用域，实际上只有一个全局变量i1234for (let i=0;i&lt;5;i++)&#123; setTimeout(function timer() &#123; console.log(i),1000&#125;);&#125;//0 1 2 3 4 123把var换成let，输出结果为0,1,2,3,4；1.因为let劫持了块作用域，每次迭代都会创建一个块作用域2.每次迭代都会重新声明i，用上一次迭代结束的值初始化这个变量"},{"title":"nodejs实现爬虫","date":"2019-08-13T14:59:22.542Z","path":"2019/08/13/node/nodejs实现爬虫/","text":"node.js爬静态网页封装函数(通过url访问服务器)function GetUrl(sUrl,success){ let http =&apos;&apos;;//把url转为url对象 let urlObj=url.parse(sUrl);//判断调用引入http模块/https模块 if (urlObj.protocol == &apos;http:&apos;){ http =require(&apos;http&apos;); } else{ http =require(&apos;https&apos;); } nodejs实现简单爬虫123const fs =require(&apos;fs&apos;);const url=require(&apos;url&apos;);const JSDOM =require(&apos;jsdom&apos;).JSDOM; 函数调用1234567891011121314GetUrl(&apos;https://www.baidu.com/&apos;,data=&gt;&#123; let DOM =new JSDOM(data); let document =DOM.window.document; let source =document.querySelector(&apos;#lg&apos;).children[0].src; let oUrl =&apos;https:&apos;+source+&apos;&apos;; GetUrl(oUrl,data=&gt;&#123; console.log(data); fs.writeFile(&apos;a.jpg&apos;,data,()=&gt; &#123; console.log(&quot;抓取成功&quot;); &#125;); &#125;);&#125;); 封装函数(通过url访问服务器)12345678910111213141516171819202122232425262728293031323334353637383940414243function GetUrl(sUrl,success)&#123; let http =&apos;&apos;; //把url转为url对象 let urlObj=url.parse(sUrl); //判断调用引入http模块/https模块 if (urlObj.protocol == &apos;http:&apos;)&#123; http =require(&apos;http&apos;); &#125; else&#123; http =require(&apos;https&apos;); &#125; //访问服务器 let req =http.request(&#123; &apos;hostname&apos;:urlObj.hostname, &apos;path&apos;:urlObj.path &#125;,res=&gt;&#123; //判断重定向 if (res.statusCode==200)&#123; let arr =[]; let str=&apos;&apos;; //res.on(&apos;data&apos;,()=&gt;&#123;&#125;)node访问post数据 res.on(&apos;data&apos;,buffer=&gt;&#123; arr.push(buffer); str +=buffer; &#125;); //访问完成 res.on(&apos;end&apos;,()=&gt;&#123; //数据转为Buffer let b =Buffer.concat(arr); success &amp;&amp; success(b); &#125;); &#125; else if(res.statusCode==302||res.statusCode==301)&#123; //递归调用 GetUrl(res.headers.location,success); &#125; &#125;); req.end(); req.on(&quot;error&quot;, ()=&gt;&#123; console.log(&apos;404-not found&apos;); &#125;)&#125;"},{"title":"js类型","date":"2019-08-07T14:53:00.058Z","path":"2019/08/07/js基础/js类型/","text":"js的类型基础js一共有7种内置类型分别是null，undefined，boolean，string，number，object，symbol 用typeof运算符可查看值的类型 返回的是一个字符串 特殊例子(js遗留下来的一个bug) typeof null = “object”;另一种情况 typeof function(){} = “function”;然而function并不是js的内置类型，function也是object(对象)typeof [1,2] = “object” 数组也是object(对象) js 中变量是没有类型的，只有值才有类型12345变量在未持有值的时候为undefined变量在未声明的时候会报ReferenceError错误let a;a;//undefinedb;//ReferenceError b is not undefined (即undeclared未声明) 安全检查全局变量是否已经被声明1234567if(typeof global!==&quot;undefined&quot;)&#123; console.log(&quot;全局变量已声明&quot;);&#125;另一种方式通过浏览器的全局对象windowif(window.global)&#123; console.log(&quot;全局变量已声明&quot;);&#125;"},{"title":"node读取表单并写入数据库2","date":"2019-06-05T13:30:12.920Z","path":"2019/06/05/node/表单提交2/","text":"node读取表单并写入数据库212345//引入http，url,fs,queryString let http = require(&quot;http&quot;); let url = require(&quot;url&quot;); let fs = require(&quot;fs&quot;); let queryString =require(&quot;querystring&quot;); 123456789101112131415161718192021222324//引入http，url,fs,queryStringlet http = require(&quot;http&quot;);let url = require(&quot;url&quot;);let fs = require(&quot;fs&quot;);let queryString =require(&quot;querystring&quot;);let mongodb=require(&quot;./dataBase&quot;);//创建服务 request responselet server =http.createServer((req,res)=&gt;&#123; if(req.url===&quot;/postData&quot; &amp;&amp; req.method.toLowerCase()===&quot;post&quot;)&#123; let allData =&quot;&quot;; //nodejs用req.on(data)接收客户端的数据 req.on(&quot;data&quot;,(buf)=&gt;&#123; allData +=buf; &#125;); req.once(&quot;end&quot;,()=&gt;&#123; res.end(&quot;OK!&quot;); //将字符串转成对象。说白了其实就是把url上带的参数串转成数组对象。 let dataObj = queryString.parse(allData); //创建data.txt let fd =fs.open(&quot;data.txt&quot;,&quot;w&quot;,(err,fd)=&gt;&#123; if(!err)&#123; //写入data.txt fs.writeFile(fd,[dataObj.name,dataObj.password],(err)=&gt;&#123; if(!err)&#123; 数据库操作12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//写入数据库let data = fs.readFileSync(&quot;data.txt&quot;,&quot;utf-8&quot;);console.log(data);let arr = data.split(&quot;,&quot;);console.log(arr);//增加mongodb.create([ &#123;name:arr[0],password: arr[1]&#125;],(err)=&gt;&#123; if (!err)&#123; console.log(&quot;插入成功&quot;); &#125; else&#123; throw err; &#125;&#125;);//查询mongodb.find(&#123;&#125;,&#123;name:1,password:1,_id:0&#125;,(err,docs)=&gt;&#123; console.log(&quot;开始查询&quot;); console.log(docs); console.log(&quot;查询完成&quot;); if (!err)&#123; //将docs转换成JSON let datas = JSON.stringify(docs); let fd =fs.open(&quot;test.json&quot;,&quot;w&quot;,(err,fd)=&gt;&#123; if(!err)&#123; //写入 fs.writeFile(fd,[datas],(err)=&gt;&#123; if(!err)&#123; console.log(&quot;写入成功&quot;); &#125;else&#123; throw err; &#125; fs.close(fd,(err)=&gt;&#123; if (!err)&#123; console.log(&quot;文件已经保存&quot;); &#125;else&#123; throw err; &#125; &#125;) &#125;); &#125;else&#123; throw err; &#125; &#125;); &#125;else&#123; throw err; &#125;&#125;); 数据库操作1234567891011121314151617181920 console.log(&quot;写入成功&quot;); &#125;else&#123; throw err; &#125; fs.close(fd,(err)=&gt;&#123; if (!err)&#123; console.log(&quot;文件已经保存&quot;); &#125;else&#123; throw err; &#125; &#125;) &#125;); &#125;else&#123; throw err; &#125; &#125;); &#125;); &#125;&#125;).listen(80,&quot;127.0.0.1&quot;); 数据库12345678910111213141516let fs =require(&quot;fs&quot;);let mongoose =require(&quot;mongoose&quot;);mongoose.connect(&quot;mongodb://localhost/m_data&quot;,&#123;useNewUrlParser: true&#125;);mongoose.connection.once(&quot;open&quot;,()=&gt;&#123; console.log(&quot;数据库连接成功&quot;);&#125;);//创建Schema(模式对象)let Schema =mongoose.Schema;let personSchema =new Schema(&#123; name :String, password:String&#125;);//创建Model对象let personModel =mongoose.model(&quot;person&quot;,personSchema);module.exports=personModel;"},{"title":"node表单读取与数据库存储","date":"2019-06-02T13:57:12.534Z","path":"2019/06/02/node/表单提交1/","text":"node读取表单并写入数据库 123456//引入http，url,fs,queryString let http = require(&quot;http&quot;); let url = require(&quot;url&quot;); let fs = require(&quot;fs&quot;); let queryString =require(&quot;querystring&quot;); //创建服务 request response html部分123456&lt;form id=&quot;register&quot; action=&quot;http://127.0.0.1/postData&quot; method=&quot;post&quot;&gt; &lt;p&gt;用户名&lt;input type=&quot;text&quot; id=&quot;oName&quot; name=&quot;name&quot; &gt;&lt;br&gt;&lt;/p&gt; &lt;p&gt;密码&lt;input type=&quot;password&quot; id=&quot;oPassword&quot; name=&quot;password&quot;&gt;&lt;br&gt;&lt;/p&gt; &lt;p&gt;&lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/p&gt;&lt;/form&gt; nodejs部分123456789101112131415161718192021222324252627//引入http，url,fs,queryStringlet http = require(&quot;http&quot;);let url = require(&quot;url&quot;);let fs = require(&quot;fs&quot;);let queryString =require(&quot;querystring&quot;);//创建服务 request responselet server =http.createServer((req,res)=&gt;&#123; if(req.url===&quot;/postData&quot; &amp;&amp; req.method.toLowerCase()===&quot;post&quot;)&#123; let allData =&quot;&quot;; //nodejs用req.on(data)接收客户端的数据 req.on(&quot;data&quot;,(buf)=&gt;&#123; allData +=buf; &#125;); req.once(&quot;end&quot;,()=&gt;&#123; res.end(&quot;OK!&quot;); //将字符串转成对象。说白了其实就是把url上带的参数串转成数组对象。 let dataObj = queryString.parse(allData); console.log(dataObj); console.log(dataObj.name); console.log(dataObj.password); //创建data.txt let fd =fs.open(&quot;data.txt&quot;,&quot;w&quot;,(err,fd)=&gt;&#123; if(!err)&#123; //写入 fs.writeFile(fd,[dataObj.name,dataObj.password],(err)=&gt;&#123; if(!err)&#123; 数据库操作部分12345678910111213141516171819202122232425262728293031323334//连接数据库let mongoose =require(&quot;mongoose&quot;);mongoose.connect(&quot;mongodb://localhost/m_data&quot;,&#123;useNewUrlParser: true&#125;);mongoose.connection.once(&quot;open&quot;,()=&gt;&#123; console.log(&quot;数据库连接成功&quot;);&#125;);//创建Schema(模式对象)let Schema =mongoose.Schema;let personSchema =new Schema(&#123; name :String, password:String&#125;);//创建Model对象let personModel =mongoose.model(&quot;person&quot;,personSchema);//同步读取文件let data = fs.readFileSync(&quot;data.txt&quot;,&quot;utf-8&quot;);console.log(data);let arr = data.split(&quot;,&quot;);console.log(arr);//增加personModel.create([ &#123;name:arr[0],password: arr[1]&#125;],(err)=&gt;&#123; if (!err)&#123; console.log(&quot;插入成功&quot;); &#125; else&#123; throw err; &#125;&#125;); 1234567891011121314151617181920 console.log(&quot;写入成功&quot;); &#125;else&#123; throw err; &#125; fs.close(fd,(err)=&gt;&#123; if (!err)&#123; console.log(&quot;文件已经保存&quot;); &#125;else&#123; throw err; &#125; &#125;) &#125;); &#125;else&#123; throw err; &#125; &#125;); &#125;); &#125;&#125;).listen(80,&quot;127.0.0.1&quot;);"},{"title":"node写入文件","date":"2019-05-16T13:14:41.827Z","path":"2019/05/16/node/node写入流/","text":"node.js写入文件1234567891011121314151617//引入模块let fs =require(&quot;fs&quot;);//创建写入流let ws =fs.createWriteStream(&quot;question.txt&quot;);console.log(ws);//打开通道ws.once(&quot;open&quot;, () =&gt; &#123; console.log(&quot;通道已经打开&quot;);&#125;);ws.once(&quot;close&quot;, () =&gt; &#123; console.log(&quot;通道已经关闭&quot;);&#125;);//写入通道ws.write(&quot;answer1&quot;);ws.write(&quot;answer2&quot;);//关闭通道ws.end();"},{"title":"node同步/异步文件写入","date":"2019-05-16T11:58:16.113Z","path":"2019/05/16/node/异步文件写入/","text":"node同步/异步文件写入12345678910111213141516171819202122232425262728293031323334同步//导入fs 文件系统let fs =require(&quot;fs&quot;);//打开一个文件，可写//没有则会创建let fd =fs.openSync(&quot;aaa.txt&quot;,&quot;w&quot;);//写入// sync 为synchronization的缩写// n.同时; 同时性; 同步; 同期[步]录音;fs.writeFileSync(fd,&quot;今天天气晴朗&quot;);//保存并退出异步let fs = require(&quot;fs&quot;);//导入fs 文件系统//打开文件fs.open(&quot;aaaaa.txt&quot;, &quot;w&quot;, (err, fd) =&gt; &#123; //判断出错 if (!err) &#123; //写入 fs.writeFile(fd, &quot;今天天气真好&quot;, () =&gt; &#123; if (!err) &#123; console.log(&quot;写入文件成功&quot;); &#125; else &#123; throw err; &#125; //关闭文件 fs.close(fd,(err)=&gt;&#123; if (!err)&#123; console.log(&quot;文件保存并关闭&quot;); &#125; &#125;); &#125;); &#125; else &#123; throw err; &#125;&#125;);"}]